<template>
  <div v-if="depsLoaded">
    <div class="sp-token-send__holder">
      <div class="sp-component sp-token-send">
        <div class="sp-token-send__header sp-component-title">
          <h3>NFT卡券转账</h3>
          <span>|</span>
          <span>可一次转发多种卡券</span>
        </div>
        <div class="sp-token-send__main sp-box sp-shadow">
          <form class="sp-token-send__main__form">
            <div class="sp-token-send__main__rcpt__header sp-box-header">转账给</div>
            <select name="channel" v-model="transfer.channel" v-if="availableChannels.length > 0">
              <option value="">This chain</option>
              <option
                v-for="channel in availableChannels"
                v-bind:key="channel.src.channelId"
                :value="channel.src.channelId"
              >
                {{ channel.chainIdB }}
              </option>
            </select>
            <div class="sp-token-send__main__rcpt__wrapper">
              <div class="sp-token-send__main__rcpt__icon">
                <span class="sp-icon sp-icon-UpArrow" />
              </div>
              <div class="sp-token-send__main__rcpt__input sp-form-group">
                <input
                  class="sp-input"
                  name="rcpt"
                  v-model="transfer.recipient"
                  placeholder="接收地址..."
                  :disabled="!address"
                />
              </div>
              <div
                class="sp-token-send__main__rcpt__memo__btn"
                v-on:click="memoOpen = true"
                v-if="!memoOpen && address"
              >
                +添加备注
              </div>
            </div>
            <div class="sp-token-send__main__rcpt__memo__header sp-box-header" v-if="memoOpen">
              备注
              <span class="sp-icon sp-icon-Close" v-on:click="memoOpen = false"></span>
            </div>
            <div class="sp-token-send__main__rcpt__memo" v-if="memoOpen">
              <textarea class="sp-token-send__main__rcpt__memo__content sp-textarea" v-model="transfer.memo" />
            </div>
            <div class="sp-token-send__main__amt__header sp-box-header">品种</div>
            <div class="sp-token-send__main__amt__wrapper" v-if="balances.length > 0 && address">
              <SpNFTAmountSelect
                v-for="(amount, index) in transfer.amount"
                :index="index"
                :last="transfer.amount.length == 1"
                v-model="transfer.amount[index]"
                :available="balances"
                :selected="selectedDenoms"
                v-bind:key="'amount' + index"
                v-on:self-remove="transfer.amount.splice(index, 1)"
              />
              <div
                class="sp-token-send__main__amt__add"
                v-if="transfer.channel == '' && nextToAdd != null"
                v-on:click="addToken"
              >
                + 添加卡券
              </div>
            </div>
            <div class="sp-token-send__main__amt__wrapper" v-if="!address">
              <div class="sp-amount-select sp-amount-select__dummy">
                <div class="sp-form-group">
                  <div class="sp-amount-select__denom">
                    <div class="sp-amount-select__denom__selected">
                      <div class="sp-amount-select__denom__name">
                        <div class="sp-denom-marker" style="background: #809cff" />
                        <div class="sp-dummy-fill" />
                      </div>
                    </div>
                  </div>
                  <input class="sp-input sp-input-large" value="0" name="rcpt" disabled="true" />
                </div>
              </div>
            </div>

            <div
              class="sp-token-send__main__footer"
              :class="{ 'sp-token-send__main__footer__open': feesOpen }"
              v-if="address"
            >
              <div class="sp-token-send__main__fees__header sp-box-header">
                手续费 <span class="sp-circle">?</span>
                <span v-if="feesOpen" v-on:click="feesOpen = false" class="sp-icon sp-icon-UpCaret"></span>
              </div>
              <div class="sp-token-send__main__fees__content">
                <template v-if="feesOpen">
                  <div class="sp-token-send__main__amt__wrapper" v-if="!balances">
                    <SpAmountSelect
                      v-for="(amount, index) in transfer.fees"
                      :index="index"
                      :last="transfer.fees.length == 1"
                      v-model="transfer.fees[index]"
                      :available="tokenBalances"
                      :selected="selectedFeeDenoms"
                      v-bind:key="'fee' + index"
                      v-on:self-remove="transfer.fees.splice(index, 1)"
                    />
                    <div class="sp-token-send__main__amt__add" v-if="nextFeeToAdd != null" v-on:click="addFeeToken">
                      + 添加手续费
                    </div>
                    <div class="sp-line"></div>
                  </div>
                </template>
                <template v-else>
                  <div class="sp-token-send__main__fees__small">
                    <span v-for="(fee, index) in transfer.fees" v-bind:key="'fee_small' + index">
                      <strong>{{ fee.amount }}</strong>

                      <template v-if="fee.denom.indexOf('ibc/') == 0">
                        IBC/{{ denomTraces[fee.denom.split('/')[1]]?.denom_trace.path.toUpperCase() ?? '' }}/{{
                          denomTraces[fee.denom.split('/')[1]]?.denom_trace.base_denom.toUpperCase() ?? 'UNKNOWN'
                        }},
                      </template>
                      <template v-else> {{ fee.denom }}, </template>
                    </span>
                    <span v-on:click="feesOpen = true" class="sp-icon sp-icon-DownCaret"></span>
                  </div>
                </template>
              </div>
              <div class="sp-token-send__main__btns">
                <div class="sp-token-send__main__btns__reset__fees" v-on:click="resetFees" v-if="feesOpen">
                  重设手续费
                </div>
                <div class="sp-token-send__main__btns__tx">
                  <div class="sp-token-send__main__btns__reset" v-on:click="resetTransaction">重设</div>
                  <SpButton v-on:click="sendTransaction" type="primar" :disabled="!validForm" :busy="inFlight"
                    >确认转账</SpButton
                  >
                </div>
              </div>
            </div>
            <div class="sp-token-send__main__footer" v-else>
              <h3 style="color:red">请先登录钱包</h3>
              <div class="sp-token-send__main__fees__content"></div>
              <div class="sp-token-send__main__btns">
                <div class="sp-token-send__main__btns__reset__fees" v-on:click="resetFees" v-if="feesOpen">
                  重设手续费
                </div>
                <div class="sp-token-send__main__btns__tx">
                  <SpButton v-on:click="sendTransaction" type="primary" :disabled="!validForm"
                    >确认转账</SpButton
                  >
                </div>
              </div>
            </div>
          </form>
        </div>
      </div>
      <div class="sp-component sp-assets__wrapper">
        <SpNFTAssets :address="address" v-show="address"/>
      </div>
    </div>
  </div>
</template>
<script lang="ts">
import { defineComponent, PropType } from 'vue'
import SpButton from '../SpButton'
import SpNFTAssets from '../SpNFTAssets'
import SpNFTAmountSelect from '../SpNFTAmountSelect'
import { Bech32 } from '@cosmjs/encoding'
import { Amount, DenomTraces, Relayer} from '../../utils/interfaces'
import long from 'long';

export interface TransferData {
  recipient: string
  channel: string
  amount: Array<Amount>
  memo: string
  fees: Array<Amount>
}

export interface SpNFTSendState {
  transfer: TransferData
  feesOpen: boolean
  memoOpen: boolean
  inFlight: boolean
  bankAddress: string
  staking: Record<string, unknown>
  denomTraces: DenomTraces
}


export default defineComponent({
  name: 'SpNFTSend',
  components: {
    SpButton,
    SpNFTAmountSelect,
    SpNFTAssets
  },
  props: {
    address: {
      type: String as PropType<string>,
    },
    refresh: {
      type: Boolean as PropType<boolean>,
    },
  },
  data: function (): SpNFTSendState {
    return {
      transfer: {
        recipient: '',
        channel: '',
        amount: [],
        memo: '',
        fees: [],
      } as TransferData,
      feesOpen: false,
      memoOpen: false,
      inFlight: false,
      bankAddress: '',
      staking: {},
      denomTraces: {} as DenomTraces,
    }
  },
  beforeCreate: function (): void {
    const vuexModule = ['irismod.nft']
    for (let i = 1; i <= vuexModule.length; i++) {
      const submod = vuexModule.slice(0, i)
      if (!this.$store.hasModule(submod)) {
        console.log('Module `irismod.nft` has not been registered!')
        this._depsLoaded = false
        break
      }
    }
  },
  created:function() {
    this.bankAddress = this.address ?? ''
    this.staking = this.$store.getters['cosmos.staking.v1beta1/getParams']()
    if (this._depsLoaded) {
      if (this.bankAddress != '') {
         this.$store.dispatch('cosmos.bank.v1beta1/QueryAllBalances', {
          params: { address: this.address },
          options: { all: true, subscribe: this.refresh },
        })
      }
    }
  },
  mounted: function (): void {
    this.bankAddress = this.address ?? ''
    if (this._depsLoaded) {
      if (this.bankAddress != '') {
          this.$store.dispatch('irismod.nft/QueryOwner', {
            query: { owner: this.address }
          })
      }
    }
  },
  watch: {
    balances: function (newBal: any, oldBal: any): void {
      if (newBal != oldBal && newBal[0]?.denom && oldBal.length == 0) {
        this.transfer.amount = [{ amount: newBal[0].amount, denom: newBal[0].denom } ]
      }
    },
    tokenBalances: function (newtokenBal: any, oldtokenBal: any): void {
      if (newtokenBal != oldtokenBal && newtokenBal[0]?.denom && oldtokenBal.length == 0) {
        this.transfer.fees = [{ amount: '', denom: newtokenBal[0].denom }]
      }
    },
    address: function (newAddr: string, oldAddr: string): void {
      if (this._depsLoaded) {
        if (newAddr != oldAddr) {
          this.bankAddress = newAddr
          if (this.bankAddress != '') {
            this.$store.dispatch('irismod.nft/QueryOwner', {
              query: { owner: this.address }
            })
            this.$store.dispatch('cosmos.bank.v1beta1/QueryAllBalances', {
              params: { address: this.bankAddress },
              options: { subscribe: this.refresh },
            })
          }
        }
      }
    },
  },
  computed: {
    validForm: function (): boolean {
      if (
        // this.transfer.amount.every(
        //   (x) => !isNaN(this.parseAmount(x.amount)) && x.amount != '' && this.parseAmount(x.amount) != 0,
        // ) &&
        // this.transfer.fees.every((x) => !isNaN(this.parseAmount(x.amount))) &&
        this.validAddress &&
        this.address
      ) {
        return true
      } else {
        return false
      }
    },
    balances: function (): Array<Amount> {
      if (this._depsLoaded &&  this.bankAddress != '') {
        var res = this.$store.getters['irismod.nft/getOwner']({
              params: {},
              query: { owner: this.bankAddress }, 
              })?.owner?.id_collections; 
        var ret: Array<Amount>=[];
        //console.log(res);
        if (res) {  
          for (let idCollection of res){
            for (let tokenId of idCollection?.token_ids){
              ret.push({denom:tokenId, amount: idCollection?.denom_id});
            }
          }
        }
        //console.log(ret);
        return ret
       } else {
        return []
       }
    },
    tokenBalances: function (): Array<Amount> {        
      if (this._depsLoaded &&  this.bankAddress != '') {
        var ret=this.$store.getters['cosmos.bank.v1beta1/getAllBalances']({
            params: { address: this.bankAddress },
          })?.balances ?? []
        console.log(ret)
        return (
          ret
        )
      } else {
        return []
      }
    },
    nextToAdd: function (): Amount | null {
      const i = this.balances.findIndex((x) => !this.selectedDenoms.includes(x.denom))
      if (i == -1) {
        return null
      } else {
        return this.balances[i]
      }
    },
    nextFeeToAdd: function (): Amount | null {
      const i = this.tokenBalances.findIndex((x) => !this.selectedFeeDenoms.includes(x.denom))
      if (i == -1) {
        return null
      } else {
        return this.tokenBalances[i]
      }
    },
    selectedDenoms: function (): Array<string> {
      return this.transfer.amount.map((x) => x.denom)
    },
    selectedFeeDenoms: function (): Array<string> {
      return this.transfer.fees.map((x) => x.denom)
    },
    fullBalances: function (): any {
      return this.balances.map((x) => {
        this.addMapping(x)
        return x
      })
    },
    relayers: function (): Array<Relayer> {
      return this.$store.hasModule(['common', 'relayers']) ? this.$store.getters['common/relayers/getRelayers'] : []
    },
    availableChannels: function (): Array<Relayer> {
      return this.relayers?.filter((x) => x.status == 'connected') ?? []
    },
    depsLoaded: function (): boolean {
      return this._depsLoaded
    },
    validAddress: function (): boolean {
      let toAddress
      try {
        toAddress = !!Bech32.decode(this.transfer.recipient)
      } catch {
        toAddress = false
      }
      return toAddress
    },
  },
  methods: {
    parseAmount(amount: string): number {
      return amount == '' ? 0 : parseInt(amount)
    },
    addMapping: async function (balance: Amount): Promise<void> {
      if (balance.denom.indexOf('ibc/') == 0) {
        const denom = balance.denom.split('/')
        const hash = denom[1]
        this.denomTraces[hash] = await this.$store.dispatch('ibc.applications.transfer.v1/QueryDenomTrace', {
          options: { subscribe: false, all: false },
          params: { hash },
        })
      }
    },
    resetTransaction: function (): void {
      this.transfer.amount = [{ amount: this.balances[0]?.amount, denom: this.balances[0]?.denom }]
      this.transfer.recipient = ''
      this.transfer.memo = ''
      this.transfer.channel = ''
      this.transfer.fees = [{ amount: '', denom: this.tokenBalances[0]?.denom }]
      this.feesOpen = false
      this.memoOpen = false
    },
    resetFees: function (): void {
      this.transfer.fees = [{ amount: '', denom: this.tokenBalances[0]?.denom }]
    },
    addToken: function (): void {
      this.transfer.amount.push({
        amount: this.nextToAdd?.amount ?? '',
        denom: this.nextToAdd?.denom ?? '',
      })
    },
    addFeeToken: function (): void {
      this.transfer.fees.push({
        amount: '',
        denom: this.nextFeeToAdd?.denom ?? '',
      })
    },
    
    sendTransaction: async function (): Promise<void> {
      if (this._depsLoaded && this.address) {
        if (this.validForm && !this.inFlight) {
          var i:number;
          for(i = 0;i<this.transfer.amount.length;i++)  {
            const value = {
              id: this.transfer.amount[i].denom,
              denomId: this.transfer.amount[i].amount,
              recipient: this.transfer.recipient,
              sender: this.address,
            }

            this.inFlight = true
            this.transfer.fees.forEach((x) => {
              if (x.amount == '') {
                x.amount = '0'
              }
            })
            try {
              console.log(value);
              const txResult = await this.$store.dispatch('irismod.nft/sendMsgTransfernft', {
                value,
                fee: this.transfer.fees,
                memo: this.transfer.memo,
              })
              console.log(txResult);
              if (txResult && !txResult.code) {
                this.resetTransaction()
              }
            } catch (e) {
              console.error(e)
            } finally {
              this.inFlight = false
            }
          }
          var res=await this.$store.dispatch('irismod.nft/QueryOwner', {
              query: { owner: this.address }
           })
        }
      }
    },
  },
})
</script>
