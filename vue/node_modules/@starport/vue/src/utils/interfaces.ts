export interface Account {
  address: string
  pathIncrement: number
}
export type Wallet = {
  name: string
  mnemonic: string | null
  HDpath: string | null
  password: string | null
  prefix: string
  pathIncrement: number
  accounts: Account[]
}

export interface Amount {
  amount: string
  denom: string
}
export type ColoredAmount = Amount & { color: string }
export interface DenomTrace {
  denom_trace: { path: string; base_denom: string }
}
export interface DenomTraces {
  [key: string]: DenomTrace
}
export type Block = {
  height: number
} & {
  [key: string]: string | undefined
}
export interface IBCAckHeights {
  packetHeightA: number
  packetHeightB: number
  ackHeightA: number
  ackHeightB: number
}
export interface IBCEndpoint {
  clientID: string
  connectionID: string
}
export interface IBCChannel {
  portId?: string
  channelId: string
}
export interface Relayer {
  name: string
  prefix?: string
  endpoint?: string
  gasPrice?: string
  external: boolean
  status: 'connected' | 'linked' | 'created'
  heights?: IBCAckHeights
  running?: boolean
  chainIdA?: string
  chainIdB: string
  targetAddress?: string
  endA?: IBCEndpoint
  endB?: IBCEndpoint
  src: IBCChannel
  dest?: IBCChannel
}

export interface Transactions {
  txs: Array<RawTransaction>
  tx_responses: Array<RawTransactionResponse>
}
export type RawTransactionResponse = {
  height: number
  code: number
} & {
  [key: string]: string | undefined
}
export interface TxPacket {
  data: string
  source_port: string
  source_channel: string
  destination_port: string
  destination_channel: string
}
export interface TxDecodedPacket {
  sender?: string
  receiver?: string
  amount?: string
  denom?: string
}
export interface TxMessage {
  '@type': string
  packet?: TxPacket
  signer: string
  connection_id?: string
  client_id?: string
  amount?: Amount[]
  token?: Amount
  counterparty_connection_id?: string
  previous_connection_id?: string
  from_address?: string
  to_address?: string
  sender?: string
  receiver?: string
  port_id?: string
  channel_id?: string
  source_channel?: string
  counterparty_version?: string
  previous_channel_id?: string
  data?: string
  denom_id?: string
  id?: string
  name?: string
  recipient?: String
  uri?: string
  uri_hash?: string
}

export interface TxBody {
  messages: Array<TxMessage>
}
export type RawTransaction = {
  response: RawTransactionResponse
  body: TxBody
} & {
  [key: string]: unknown
}
export type Transaction = RawTransaction & {
  [key: string]: unknown
}
export interface SpTypeObject {
  id?: string
  creator?: string
  [key: string]: string | undefined
}
export interface Field {
  name: string
  type: string
}
export type AmountWithMeta = Amount & {
  coinDenom: string
  coinMinimalDenom: string
  coinDecimals: number
}

import * as iris from 'irishub-sdk-js'
import { Client } from 'irishub-sdk-js'

export class Consts {
  static timeout = 10000;
  static keyName = 'test1';
  static keyPassword = 'linux123';
}
export interface Collection{
  denomId: String;
  tokenIdsList: String[]
}
export interface NFTData{
  address: String;
  idCollectionsList: Collection[]
}
export interface NFTObj {
    owner: NFTData;
}

/** Test KeyDAO */
export class TestKeyDAO implements iris.KeyDAO {
  keyMap: { [key: string]: iris.types.Wallet } = {};
  write(name: string, key: iris.types.Wallet) {
    this.keyMap[name] = key;
  }
  read(name: string): iris.types.Wallet {
    return this.keyMap[name];
  }
  delete(name: string) {
    delete this.keyMap[name];
  }
}

export class BaseTest {
  static baseTx: iris.types.BaseTx = {
    from: Consts.keyName,
    password: Consts.keyPassword,
    mode: iris.types.BroadcastMode.Commit,
  };

static getClient(): Client {
    let config = {
        node: 'http://localhost:26657',
        chainNetwork: iris.types.ChainNetwork.Iris,
        chainId: 'metab',
        gas: '20000000',
        fee: { denom: 'metab', amount: '1' },
    };

    const client = iris
      .newClient(config)
      .withKeyDAO(new TestKeyDAO())
      .withRpcConfig({ timeout: Consts.timeout });

    return client;
  }
}