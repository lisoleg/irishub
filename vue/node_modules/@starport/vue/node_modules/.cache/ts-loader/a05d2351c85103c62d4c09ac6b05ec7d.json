{"remainingRequest":"/home/lisoleg/cosmos/checkers/vue/node_modules/@starport/vue/node_modules/thread-loader/dist/cjs.js!/home/lisoleg/cosmos/checkers/vue/node_modules/@starport/vue/node_modules/babel-loader/lib/index.js!/home/lisoleg/cosmos/checkers/vue/node_modules/@starport/vue/node_modules/ts-loader/index.js??clonedRuleSet-131.use[3]!/home/lisoleg/cosmos/checkers/vue/node_modules/@starport/vue/src/utils/interfaces.ts","dependencies":[{"path":"/home/lisoleg/cosmos/checkers/vue/node_modules/@starport/vue/src/utils/interfaces.ts","mtime":1650151799484},{"path":"/home/lisoleg/cosmos/checkers/vue/node_modules/@starport/vue/babel.config.js","mtime":1642396933629},{"path":"/home/lisoleg/cosmos/checkers/vue/node_modules/@starport/vue/node_modules/cache-loader/dist/cjs.js","mtime":1642436200407},{"path":"/home/lisoleg/cosmos/checkers/vue/node_modules/@starport/vue/node_modules/thread-loader/dist/cjs.js","mtime":1642436200217},{"path":"/home/lisoleg/cosmos/checkers/vue/node_modules/@starport/vue/node_modules/babel-loader/lib/index.js","mtime":1642436202647},{"path":"/home/lisoleg/cosmos/checkers/vue/node_modules/@starport/vue/node_modules/ts-loader/index.js","mtime":1642436203297}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tICIvaG9tZS9saXNvbGVnL2Nvc21vcy9jaGVja2Vycy92dWUvbm9kZV9tb2R1bGVzL0BzdGFycG9ydC92dWUvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5LmpzIjsKaW1wb3J0ICogYXMgaXJpcyBmcm9tICdpcmlzaHViLXNkay1qcyc7CmV4cG9ydCBjbGFzcyBDb25zdHMge30KLyoqIFRlc3QgS2V5REFPICovCgpfZGVmaW5lUHJvcGVydHkoQ29uc3RzLCAidGltZW91dCIsIDEwMDAwKTsKCl9kZWZpbmVQcm9wZXJ0eShDb25zdHMsICJrZXlOYW1lIiwgJzAwMDMnKTsKCl9kZWZpbmVQcm9wZXJ0eShDb25zdHMsICJrZXlQYXNzd29yZCIsICdsaW51eDEyMycpOwoKZXhwb3J0IGNsYXNzIFRlc3RLZXlEQU8gewogIGNvbnN0cnVjdG9yKCkgewogICAgX2RlZmluZVByb3BlcnR5KHRoaXMsICJrZXlNYXAiLCB7fSk7CiAgfQoKICB3cml0ZShuYW1lLCBrZXkpIHsKICAgIHRoaXMua2V5TWFwW25hbWVdID0ga2V5OwogIH0KCiAgcmVhZChuYW1lKSB7CiAgICByZXR1cm4gdGhpcy5rZXlNYXBbbmFtZV07CiAgfQoKICBkZWxldGUobmFtZSkgewogICAgZGVsZXRlIHRoaXMua2V5TWFwW25hbWVdOwogIH0KCn0KZXhwb3J0IGNsYXNzIEJhc2VUZXN0IHsKICBzdGF0aWMgZ2V0Q2xpZW50KCkgewogICAgbGV0IGNvbmZpZyA9IHsKICAgICAgbm9kZTogJ2h0dHA6Ly9sb2NhbGhvc3Q6MjY2NTcnLAogICAgICBjaGFpbk5ldHdvcms6IGlyaXMudHlwZXMuQ2hhaW5OZXR3b3JrLklyaXMsCiAgICAgIGNoYWluSWQ6ICdtZXRhYicsCiAgICAgIGdhczogJzIwMDAwMDAwJywKICAgICAgZmVlOiB7CiAgICAgICAgZGVub206ICdtZXRhYicsCiAgICAgICAgYW1vdW50OiAnMScKICAgICAgfQogICAgfTsKICAgIGNvbnN0IGNsaWVudCA9IGlyaXMubmV3Q2xpZW50KGNvbmZpZykud2l0aEtleURBTyhuZXcgVGVzdEtleURBTygpKS53aXRoUnBjQ29uZmlnKHsKICAgICAgdGltZW91dDogQ29uc3RzLnRpbWVvdXQKICAgIH0pOwogICAgcmV0dXJuIGNsaWVudDsKICB9Cgp9CgpfZGVmaW5lUHJvcGVydHkoQmFzZVRlc3QsICJiYXNlVHgiLCB7CiAgZnJvbTogQ29uc3RzLmtleU5hbWUsCiAgcGFzc3dvcmQ6IENvbnN0cy5rZXlQYXNzd29yZCwKICBtb2RlOiBpcmlzLnR5cGVzLkJyb2FkY2FzdE1vZGUuQ29tbWl0Cn0pOw=="},{"version":3,"sources":["/home/lisoleg/cosmos/checkers/vue/node_modules/@starport/vue/src/utils/interfaces.ts"],"names":[],"mappings":";AA4IA,OAAO,KAAK,IAAZ,MAAsB,gBAAtB;AAGA,OAAM,MAAO,MAAP,CAAa;AAiBnB;;gBAjBa,M,aACM,K;;gBADN,M,aAEM,M;;gBAFN,M,iBAGU,U;;AAevB,OAAM,MAAO,UAAP,CAAiB;AAAA;AAAA,oCAC0B,EAD1B;AAAA;;AAErB,EAAA,KAAK,CAAC,IAAD,EAAe,GAAf,EAAqC;AACxC,SAAK,MAAL,CAAY,IAAZ,IAAoB,GAApB;AACD;;AACD,EAAA,IAAI,CAAC,IAAD,EAAa;AACf,WAAO,KAAK,MAAL,CAAY,IAAZ,CAAP;AACD;;AACD,EAAA,MAAM,CAAC,IAAD,EAAa;AACjB,WAAO,KAAK,MAAL,CAAY,IAAZ,CAAP;AACD;;AAVoB;AAavB,OAAM,MAAO,QAAP,CAAe;AAOL,SAAT,SAAS,GAAA;AACZ,QAAI,MAAM,GAAG;AACT,MAAA,IAAI,EAAE,wBADG;AAET,MAAA,YAAY,EAAE,IAAI,CAAC,KAAL,CAAW,YAAX,CAAwB,IAF7B;AAGT,MAAA,OAAO,EAAE,OAHA;AAIT,MAAA,GAAG,EAAE,UAJI;AAKT,MAAA,GAAG,EAAE;AAAE,QAAA,KAAK,EAAE,OAAT;AAAkB,QAAA,MAAM,EAAE;AAA1B;AALI,KAAb;AAQA,UAAM,MAAM,GAAG,IAAI,CAChB,SADY,CACF,MADE,EAEZ,UAFY,CAED,IAAI,UAAJ,EAFC,EAGZ,aAHY,CAGE;AAAE,MAAA,OAAO,EAAE,MAAM,CAAC;AAAlB,KAHF,CAAf;AAKA,WAAO,MAAP;AACD;;AAtBkB;;gBAAR,Q,YACwB;AACjC,EAAA,IAAI,EAAE,MAAM,CAAC,OADoB;AAEjC,EAAA,QAAQ,EAAE,MAAM,CAAC,WAFgB;AAGjC,EAAA,IAAI,EAAE,IAAI,CAAC,KAAL,CAAW,aAAX,CAAyB;AAHE,C","sourcesContent":["export interface Account {\n  address: string\n  pathIncrement: number\n}\nexport type Wallet = {\n  name: string\n  mnemonic: string | null\n  HDpath: string | null\n  password: string | null\n  prefix: string\n  pathIncrement: number\n  accounts: Account[]\n}\n\nexport interface Amount {\n  amount: string\n  denom: string\n}\nexport type ColoredAmount = Amount & { color: string }\nexport interface DenomTrace {\n  denom_trace: { path: string; base_denom: string }\n}\nexport interface DenomTraces {\n  [key: string]: DenomTrace\n}\nexport type Block = {\n  height: number\n} & {\n  [key: string]: string | undefined\n}\nexport interface IBCAckHeights {\n  packetHeightA: number\n  packetHeightB: number\n  ackHeightA: number\n  ackHeightB: number\n}\nexport interface IBCEndpoint {\n  clientID: string\n  connectionID: string\n}\nexport interface IBCChannel {\n  portId?: string\n  channelId: string\n}\nexport interface Relayer {\n  name: string\n  prefix?: string\n  endpoint?: string\n  gasPrice?: string\n  external: boolean\n  status: 'connected' | 'linked' | 'created'\n  heights?: IBCAckHeights\n  running?: boolean\n  chainIdA?: string\n  chainIdB: string\n  targetAddress?: string\n  endA?: IBCEndpoint\n  endB?: IBCEndpoint\n  src: IBCChannel\n  dest?: IBCChannel\n}\n\nexport interface Transactions {\n  txs: Array<RawTransaction>\n  tx_responses: Array<RawTransactionResponse>\n}\nexport type RawTransactionResponse = {\n  height: number\n  code: number\n} & {\n  [key: string]: string | undefined\n}\nexport interface TxPacket {\n  data: string\n  source_port: string\n  source_channel: string\n  destination_port: string\n  destination_channel: string\n}\nexport interface TxDecodedPacket {\n  sender?: string\n  receiver?: string\n  amount?: string\n  denom?: string\n}\nexport interface TxMessage {\n  '@type': string\n  packet?: TxPacket\n  signer: string\n  connection_id?: string\n  client_id?: string\n  amount?: Amount[]\n  token?: Amount\n  counterparty_connection_id?: string\n  previous_connection_id?: string\n  from_address?: string\n  to_address?: string\n  sender?: string\n  receiver?: string\n  port_id?: string\n  channel_id?: string\n  source_channel?: string\n  counterparty_version?: string\n  previous_channel_id?: string\n  data?: string\n  denom_id?: string\n  id?: string\n  name?: string\n  recipient?: String\n  uri?: string\n  uri_hash?: string\n}\n\nexport interface TxBody {\n  messages: Array<TxMessage>\n}\nexport type RawTransaction = {\n  response: RawTransactionResponse\n  body: TxBody\n} & {\n  [key: string]: unknown\n}\nexport type Transaction = RawTransaction & {\n  [key: string]: unknown\n}\nexport interface SpTypeObject {\n  id?: string\n  creator?: string\n  [key: string]: string | undefined\n}\nexport interface Field {\n  name: string\n  type: string\n}\nexport type AmountWithMeta = Amount & {\n  coinDenom: string\n  coinMinimalDenom: string\n  coinDecimals: number\n}\n\nimport * as iris from 'irishub-sdk-js'\nimport { Client } from 'irishub-sdk-js'\n\nexport class Consts {\n  static timeout = 10000;\n  static keyName = '0003';\n  static keyPassword = 'linux123';\n}\nexport interface Collection{\n  denomId: String;\n  tokenIdsList: String[]\n}\nexport interface NFTData{\n  address: String;\n  idCollectionsList: Collection[]\n}\nexport interface NFTObj {\n    owner: NFTData;\n}\n\n/** Test KeyDAO */\nexport class TestKeyDAO implements iris.KeyDAO {\n  keyMap: { [key: string]: iris.types.Wallet } = {};\n  write(name: string, key: iris.types.Wallet) {\n    this.keyMap[name] = key;\n  }\n  read(name: string): iris.types.Wallet {\n    return this.keyMap[name];\n  }\n  delete(name: string) {\n    delete this.keyMap[name];\n  }\n}\n\nexport class BaseTest {\n  static baseTx: iris.types.BaseTx = {\n    from: Consts.keyName,\n    password: Consts.keyPassword,\n    mode: iris.types.BroadcastMode.Commit,\n  };\n\nstatic getClient(): Client {\n    let config = {\n        node: 'http://localhost:26657',\n        chainNetwork: iris.types.ChainNetwork.Iris,\n        chainId: 'metab',\n        gas: '20000000',\n        fee: { denom: 'metab', amount: '1' },\n    };\n\n    const client = iris\n      .newClient(config)\n      .withKeyDAO(new TestKeyDAO())\n      .withRpcConfig({ timeout: Consts.timeout });\n\n    return client;\n  }\n}"],"sourceRoot":""}]}