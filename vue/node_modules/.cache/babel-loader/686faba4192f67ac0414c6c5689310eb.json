{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.typed-array.at.js\");\n\nrequire(\"core-js/modules/es.typed-array.set.js\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CompressedNonExistenceProof = exports.CompressedExistenceProof = exports.CompressedBatchEntry = exports.CompressedBatchProof = exports.BatchEntry = exports.BatchProof = exports.InnerSpec = exports.ProofSpec = exports.InnerOp = exports.LeafOp = exports.CommitmentProof = exports.NonExistenceProof = exports.ExistenceProof = exports.lengthOpToJSON = exports.lengthOpFromJSON = exports.LengthOp = exports.hashOpToJSON = exports.hashOpFromJSON = exports.HashOp = exports.protobufPackage = void 0;\n\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\n\nexports.protobufPackage = 'ics23';\nvar HashOp;\n\n(function (HashOp) {\n  /** NO_HASH - NO_HASH is the default if no data passed. Note this is an illegal argument some places. */\n  HashOp[HashOp[\"NO_HASH\"] = 0] = \"NO_HASH\";\n  HashOp[HashOp[\"SHA256\"] = 1] = \"SHA256\";\n  HashOp[HashOp[\"SHA512\"] = 2] = \"SHA512\";\n  HashOp[HashOp[\"KECCAK\"] = 3] = \"KECCAK\";\n  HashOp[HashOp[\"RIPEMD160\"] = 4] = \"RIPEMD160\";\n  /** BITCOIN - ripemd160(sha256(x)) */\n\n  HashOp[HashOp[\"BITCOIN\"] = 5] = \"BITCOIN\";\n  HashOp[HashOp[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(HashOp = exports.HashOp || (exports.HashOp = {}));\n\nfunction hashOpFromJSON(object) {\n  switch (object) {\n    case 0:\n    case 'NO_HASH':\n      return HashOp.NO_HASH;\n\n    case 1:\n    case 'SHA256':\n      return HashOp.SHA256;\n\n    case 2:\n    case 'SHA512':\n      return HashOp.SHA512;\n\n    case 3:\n    case 'KECCAK':\n      return HashOp.KECCAK;\n\n    case 4:\n    case 'RIPEMD160':\n      return HashOp.RIPEMD160;\n\n    case 5:\n    case 'BITCOIN':\n      return HashOp.BITCOIN;\n\n    case -1:\n    case 'UNRECOGNIZED':\n    default:\n      return HashOp.UNRECOGNIZED;\n  }\n}\n\nexports.hashOpFromJSON = hashOpFromJSON;\n\nfunction hashOpToJSON(object) {\n  switch (object) {\n    case HashOp.NO_HASH:\n      return 'NO_HASH';\n\n    case HashOp.SHA256:\n      return 'SHA256';\n\n    case HashOp.SHA512:\n      return 'SHA512';\n\n    case HashOp.KECCAK:\n      return 'KECCAK';\n\n    case HashOp.RIPEMD160:\n      return 'RIPEMD160';\n\n    case HashOp.BITCOIN:\n      return 'BITCOIN';\n\n    default:\n      return 'UNKNOWN';\n  }\n}\n\nexports.hashOpToJSON = hashOpToJSON;\n/**\n * LengthOp defines how to process the key and value of the LeafOp\n * to include length information. After encoding the length with the given\n * algorithm, the length will be prepended to the key and value bytes.\n * (Each one with it's own encoded length)\n */\n\nvar LengthOp;\n\n(function (LengthOp) {\n  /** NO_PREFIX - NO_PREFIX don't include any length info */\n  LengthOp[LengthOp[\"NO_PREFIX\"] = 0] = \"NO_PREFIX\";\n  /** VAR_PROTO - VAR_PROTO uses protobuf (and go-amino) varint encoding of the length */\n\n  LengthOp[LengthOp[\"VAR_PROTO\"] = 1] = \"VAR_PROTO\";\n  /** VAR_RLP - VAR_RLP uses rlp int encoding of the length */\n\n  LengthOp[LengthOp[\"VAR_RLP\"] = 2] = \"VAR_RLP\";\n  /** FIXED32_BIG - FIXED32_BIG uses big-endian encoding of the length as a 32 bit integer */\n\n  LengthOp[LengthOp[\"FIXED32_BIG\"] = 3] = \"FIXED32_BIG\";\n  /** FIXED32_LITTLE - FIXED32_LITTLE uses little-endian encoding of the length as a 32 bit integer */\n\n  LengthOp[LengthOp[\"FIXED32_LITTLE\"] = 4] = \"FIXED32_LITTLE\";\n  /** FIXED64_BIG - FIXED64_BIG uses big-endian encoding of the length as a 64 bit integer */\n\n  LengthOp[LengthOp[\"FIXED64_BIG\"] = 5] = \"FIXED64_BIG\";\n  /** FIXED64_LITTLE - FIXED64_LITTLE uses little-endian encoding of the length as a 64 bit integer */\n\n  LengthOp[LengthOp[\"FIXED64_LITTLE\"] = 6] = \"FIXED64_LITTLE\";\n  /** REQUIRE_32_BYTES - REQUIRE_32_BYTES is like NONE, but will fail if the input is not exactly 32 bytes (sha256 output) */\n\n  LengthOp[LengthOp[\"REQUIRE_32_BYTES\"] = 7] = \"REQUIRE_32_BYTES\";\n  /** REQUIRE_64_BYTES - REQUIRE_64_BYTES is like NONE, but will fail if the input is not exactly 64 bytes (sha512 output) */\n\n  LengthOp[LengthOp[\"REQUIRE_64_BYTES\"] = 8] = \"REQUIRE_64_BYTES\";\n  LengthOp[LengthOp[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(LengthOp = exports.LengthOp || (exports.LengthOp = {}));\n\nfunction lengthOpFromJSON(object) {\n  switch (object) {\n    case 0:\n    case 'NO_PREFIX':\n      return LengthOp.NO_PREFIX;\n\n    case 1:\n    case 'VAR_PROTO':\n      return LengthOp.VAR_PROTO;\n\n    case 2:\n    case 'VAR_RLP':\n      return LengthOp.VAR_RLP;\n\n    case 3:\n    case 'FIXED32_BIG':\n      return LengthOp.FIXED32_BIG;\n\n    case 4:\n    case 'FIXED32_LITTLE':\n      return LengthOp.FIXED32_LITTLE;\n\n    case 5:\n    case 'FIXED64_BIG':\n      return LengthOp.FIXED64_BIG;\n\n    case 6:\n    case 'FIXED64_LITTLE':\n      return LengthOp.FIXED64_LITTLE;\n\n    case 7:\n    case 'REQUIRE_32_BYTES':\n      return LengthOp.REQUIRE_32_BYTES;\n\n    case 8:\n    case 'REQUIRE_64_BYTES':\n      return LengthOp.REQUIRE_64_BYTES;\n\n    case -1:\n    case 'UNRECOGNIZED':\n    default:\n      return LengthOp.UNRECOGNIZED;\n  }\n}\n\nexports.lengthOpFromJSON = lengthOpFromJSON;\n\nfunction lengthOpToJSON(object) {\n  switch (object) {\n    case LengthOp.NO_PREFIX:\n      return 'NO_PREFIX';\n\n    case LengthOp.VAR_PROTO:\n      return 'VAR_PROTO';\n\n    case LengthOp.VAR_RLP:\n      return 'VAR_RLP';\n\n    case LengthOp.FIXED32_BIG:\n      return 'FIXED32_BIG';\n\n    case LengthOp.FIXED32_LITTLE:\n      return 'FIXED32_LITTLE';\n\n    case LengthOp.FIXED64_BIG:\n      return 'FIXED64_BIG';\n\n    case LengthOp.FIXED64_LITTLE:\n      return 'FIXED64_LITTLE';\n\n    case LengthOp.REQUIRE_32_BYTES:\n      return 'REQUIRE_32_BYTES';\n\n    case LengthOp.REQUIRE_64_BYTES:\n      return 'REQUIRE_64_BYTES';\n\n    default:\n      return 'UNKNOWN';\n  }\n}\n\nexports.lengthOpToJSON = lengthOpToJSON;\nconst baseExistenceProof = {};\nexports.ExistenceProof = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n\n    if (message.value.length !== 0) {\n      writer.uint32(18).bytes(message.value);\n    }\n\n    if (message.leaf !== undefined) {\n      exports.LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();\n    }\n\n    for (const v of message.path) {\n      exports.InnerOp.encode(v, writer.uint32(34).fork()).ldelim();\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseExistenceProof);\n    message.path = [];\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n\n        case 2:\n          message.value = reader.bytes();\n          break;\n\n        case 3:\n          message.leaf = exports.LeafOp.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          message.path.push(exports.InnerOp.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseExistenceProof);\n    message.path = [];\n\n    if (object.key !== undefined && object.key !== null) {\n      message.key = bytesFromBase64(object.key);\n    }\n\n    if (object.value !== undefined && object.value !== null) {\n      message.value = bytesFromBase64(object.value);\n    }\n\n    if (object.leaf !== undefined && object.leaf !== null) {\n      message.leaf = exports.LeafOp.fromJSON(object.leaf);\n    } else {\n      message.leaf = undefined;\n    }\n\n    if (object.path !== undefined && object.path !== null) {\n      for (const e of object.path) {\n        message.path.push(exports.InnerOp.fromJSON(e));\n      }\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.key !== undefined && (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));\n    message.value !== undefined && (obj.value = base64FromBytes(message.value !== undefined ? message.value : new Uint8Array()));\n    message.leaf !== undefined && (obj.leaf = message.leaf ? exports.LeafOp.toJSON(message.leaf) : undefined);\n\n    if (message.path) {\n      obj.path = message.path.map(e => e ? exports.InnerOp.toJSON(e) : undefined);\n    } else {\n      obj.path = [];\n    }\n\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseExistenceProof);\n    message.path = [];\n\n    if (object.key !== undefined && object.key !== null) {\n      message.key = object.key;\n    } else {\n      message.key = new Uint8Array();\n    }\n\n    if (object.value !== undefined && object.value !== null) {\n      message.value = object.value;\n    } else {\n      message.value = new Uint8Array();\n    }\n\n    if (object.leaf !== undefined && object.leaf !== null) {\n      message.leaf = exports.LeafOp.fromPartial(object.leaf);\n    } else {\n      message.leaf = undefined;\n    }\n\n    if (object.path !== undefined && object.path !== null) {\n      for (const e of object.path) {\n        message.path.push(exports.InnerOp.fromPartial(e));\n      }\n    }\n\n    return message;\n  }\n\n};\nconst baseNonExistenceProof = {};\nexports.NonExistenceProof = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n\n    if (message.left !== undefined) {\n      exports.ExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();\n    }\n\n    if (message.right !== undefined) {\n      exports.ExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseNonExistenceProof);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n\n        case 2:\n          message.left = exports.ExistenceProof.decode(reader, reader.uint32());\n          break;\n\n        case 3:\n          message.right = exports.ExistenceProof.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseNonExistenceProof);\n\n    if (object.key !== undefined && object.key !== null) {\n      message.key = bytesFromBase64(object.key);\n    }\n\n    if (object.left !== undefined && object.left !== null) {\n      message.left = exports.ExistenceProof.fromJSON(object.left);\n    } else {\n      message.left = undefined;\n    }\n\n    if (object.right !== undefined && object.right !== null) {\n      message.right = exports.ExistenceProof.fromJSON(object.right);\n    } else {\n      message.right = undefined;\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.key !== undefined && (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));\n    message.left !== undefined && (obj.left = message.left ? exports.ExistenceProof.toJSON(message.left) : undefined);\n    message.right !== undefined && (obj.right = message.right ? exports.ExistenceProof.toJSON(message.right) : undefined);\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseNonExistenceProof);\n\n    if (object.key !== undefined && object.key !== null) {\n      message.key = object.key;\n    } else {\n      message.key = new Uint8Array();\n    }\n\n    if (object.left !== undefined && object.left !== null) {\n      message.left = exports.ExistenceProof.fromPartial(object.left);\n    } else {\n      message.left = undefined;\n    }\n\n    if (object.right !== undefined && object.right !== null) {\n      message.right = exports.ExistenceProof.fromPartial(object.right);\n    } else {\n      message.right = undefined;\n    }\n\n    return message;\n  }\n\n};\nconst baseCommitmentProof = {};\nexports.CommitmentProof = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.exist !== undefined) {\n      exports.ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();\n    }\n\n    if (message.nonexist !== undefined) {\n      exports.NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();\n    }\n\n    if (message.batch !== undefined) {\n      exports.BatchProof.encode(message.batch, writer.uint32(26).fork()).ldelim();\n    }\n\n    if (message.compressed !== undefined) {\n      exports.CompressedBatchProof.encode(message.compressed, writer.uint32(34).fork()).ldelim();\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseCommitmentProof);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.exist = exports.ExistenceProof.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          message.nonexist = exports.NonExistenceProof.decode(reader, reader.uint32());\n          break;\n\n        case 3:\n          message.batch = exports.BatchProof.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          message.compressed = exports.CompressedBatchProof.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseCommitmentProof);\n\n    if (object.exist !== undefined && object.exist !== null) {\n      message.exist = exports.ExistenceProof.fromJSON(object.exist);\n    } else {\n      message.exist = undefined;\n    }\n\n    if (object.nonexist !== undefined && object.nonexist !== null) {\n      message.nonexist = exports.NonExistenceProof.fromJSON(object.nonexist);\n    } else {\n      message.nonexist = undefined;\n    }\n\n    if (object.batch !== undefined && object.batch !== null) {\n      message.batch = exports.BatchProof.fromJSON(object.batch);\n    } else {\n      message.batch = undefined;\n    }\n\n    if (object.compressed !== undefined && object.compressed !== null) {\n      message.compressed = exports.CompressedBatchProof.fromJSON(object.compressed);\n    } else {\n      message.compressed = undefined;\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.exist !== undefined && (obj.exist = message.exist ? exports.ExistenceProof.toJSON(message.exist) : undefined);\n    message.nonexist !== undefined && (obj.nonexist = message.nonexist ? exports.NonExistenceProof.toJSON(message.nonexist) : undefined);\n    message.batch !== undefined && (obj.batch = message.batch ? exports.BatchProof.toJSON(message.batch) : undefined);\n    message.compressed !== undefined && (obj.compressed = message.compressed ? exports.CompressedBatchProof.toJSON(message.compressed) : undefined);\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseCommitmentProof);\n\n    if (object.exist !== undefined && object.exist !== null) {\n      message.exist = exports.ExistenceProof.fromPartial(object.exist);\n    } else {\n      message.exist = undefined;\n    }\n\n    if (object.nonexist !== undefined && object.nonexist !== null) {\n      message.nonexist = exports.NonExistenceProof.fromPartial(object.nonexist);\n    } else {\n      message.nonexist = undefined;\n    }\n\n    if (object.batch !== undefined && object.batch !== null) {\n      message.batch = exports.BatchProof.fromPartial(object.batch);\n    } else {\n      message.batch = undefined;\n    }\n\n    if (object.compressed !== undefined && object.compressed !== null) {\n      message.compressed = exports.CompressedBatchProof.fromPartial(object.compressed);\n    } else {\n      message.compressed = undefined;\n    }\n\n    return message;\n  }\n\n};\nconst baseLeafOp = {\n  hash: 0,\n  prehashKey: 0,\n  prehashValue: 0,\n  length: 0\n};\nexports.LeafOp = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.hash !== 0) {\n      writer.uint32(8).int32(message.hash);\n    }\n\n    if (message.prehashKey !== 0) {\n      writer.uint32(16).int32(message.prehashKey);\n    }\n\n    if (message.prehashValue !== 0) {\n      writer.uint32(24).int32(message.prehashValue);\n    }\n\n    if (message.length !== 0) {\n      writer.uint32(32).int32(message.length);\n    }\n\n    if (message.prefix.length !== 0) {\n      writer.uint32(42).bytes(message.prefix);\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseLeafOp);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.hash = reader.int32();\n          break;\n\n        case 2:\n          message.prehashKey = reader.int32();\n          break;\n\n        case 3:\n          message.prehashValue = reader.int32();\n          break;\n\n        case 4:\n          message.length = reader.int32();\n          break;\n\n        case 5:\n          message.prefix = reader.bytes();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseLeafOp);\n\n    if (object.hash !== undefined && object.hash !== null) {\n      message.hash = hashOpFromJSON(object.hash);\n    } else {\n      message.hash = 0;\n    }\n\n    if (object.prehashKey !== undefined && object.prehashKey !== null) {\n      message.prehashKey = hashOpFromJSON(object.prehashKey);\n    } else {\n      message.prehashKey = 0;\n    }\n\n    if (object.prehashValue !== undefined && object.prehashValue !== null) {\n      message.prehashValue = hashOpFromJSON(object.prehashValue);\n    } else {\n      message.prehashValue = 0;\n    }\n\n    if (object.length !== undefined && object.length !== null) {\n      message.length = lengthOpFromJSON(object.length);\n    } else {\n      message.length = 0;\n    }\n\n    if (object.prefix !== undefined && object.prefix !== null) {\n      message.prefix = bytesFromBase64(object.prefix);\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.hash !== undefined && (obj.hash = hashOpToJSON(message.hash));\n    message.prehashKey !== undefined && (obj.prehashKey = hashOpToJSON(message.prehashKey));\n    message.prehashValue !== undefined && (obj.prehashValue = hashOpToJSON(message.prehashValue));\n    message.length !== undefined && (obj.length = lengthOpToJSON(message.length));\n    message.prefix !== undefined && (obj.prefix = base64FromBytes(message.prefix !== undefined ? message.prefix : new Uint8Array()));\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseLeafOp);\n\n    if (object.hash !== undefined && object.hash !== null) {\n      message.hash = object.hash;\n    } else {\n      message.hash = 0;\n    }\n\n    if (object.prehashKey !== undefined && object.prehashKey !== null) {\n      message.prehashKey = object.prehashKey;\n    } else {\n      message.prehashKey = 0;\n    }\n\n    if (object.prehashValue !== undefined && object.prehashValue !== null) {\n      message.prehashValue = object.prehashValue;\n    } else {\n      message.prehashValue = 0;\n    }\n\n    if (object.length !== undefined && object.length !== null) {\n      message.length = object.length;\n    } else {\n      message.length = 0;\n    }\n\n    if (object.prefix !== undefined && object.prefix !== null) {\n      message.prefix = object.prefix;\n    } else {\n      message.prefix = new Uint8Array();\n    }\n\n    return message;\n  }\n\n};\nconst baseInnerOp = {\n  hash: 0\n};\nexports.InnerOp = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.hash !== 0) {\n      writer.uint32(8).int32(message.hash);\n    }\n\n    if (message.prefix.length !== 0) {\n      writer.uint32(18).bytes(message.prefix);\n    }\n\n    if (message.suffix.length !== 0) {\n      writer.uint32(26).bytes(message.suffix);\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseInnerOp);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.hash = reader.int32();\n          break;\n\n        case 2:\n          message.prefix = reader.bytes();\n          break;\n\n        case 3:\n          message.suffix = reader.bytes();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseInnerOp);\n\n    if (object.hash !== undefined && object.hash !== null) {\n      message.hash = hashOpFromJSON(object.hash);\n    } else {\n      message.hash = 0;\n    }\n\n    if (object.prefix !== undefined && object.prefix !== null) {\n      message.prefix = bytesFromBase64(object.prefix);\n    }\n\n    if (object.suffix !== undefined && object.suffix !== null) {\n      message.suffix = bytesFromBase64(object.suffix);\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.hash !== undefined && (obj.hash = hashOpToJSON(message.hash));\n    message.prefix !== undefined && (obj.prefix = base64FromBytes(message.prefix !== undefined ? message.prefix : new Uint8Array()));\n    message.suffix !== undefined && (obj.suffix = base64FromBytes(message.suffix !== undefined ? message.suffix : new Uint8Array()));\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseInnerOp);\n\n    if (object.hash !== undefined && object.hash !== null) {\n      message.hash = object.hash;\n    } else {\n      message.hash = 0;\n    }\n\n    if (object.prefix !== undefined && object.prefix !== null) {\n      message.prefix = object.prefix;\n    } else {\n      message.prefix = new Uint8Array();\n    }\n\n    if (object.suffix !== undefined && object.suffix !== null) {\n      message.suffix = object.suffix;\n    } else {\n      message.suffix = new Uint8Array();\n    }\n\n    return message;\n  }\n\n};\nconst baseProofSpec = {\n  maxDepth: 0,\n  minDepth: 0\n};\nexports.ProofSpec = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.leafSpec !== undefined) {\n      exports.LeafOp.encode(message.leafSpec, writer.uint32(10).fork()).ldelim();\n    }\n\n    if (message.innerSpec !== undefined) {\n      exports.InnerSpec.encode(message.innerSpec, writer.uint32(18).fork()).ldelim();\n    }\n\n    if (message.maxDepth !== 0) {\n      writer.uint32(24).int32(message.maxDepth);\n    }\n\n    if (message.minDepth !== 0) {\n      writer.uint32(32).int32(message.minDepth);\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseProofSpec);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.leafSpec = exports.LeafOp.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          message.innerSpec = exports.InnerSpec.decode(reader, reader.uint32());\n          break;\n\n        case 3:\n          message.maxDepth = reader.int32();\n          break;\n\n        case 4:\n          message.minDepth = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseProofSpec);\n\n    if (object.leafSpec !== undefined && object.leafSpec !== null) {\n      message.leafSpec = exports.LeafOp.fromJSON(object.leafSpec);\n    } else {\n      message.leafSpec = undefined;\n    }\n\n    if (object.innerSpec !== undefined && object.innerSpec !== null) {\n      message.innerSpec = exports.InnerSpec.fromJSON(object.innerSpec);\n    } else {\n      message.innerSpec = undefined;\n    }\n\n    if (object.maxDepth !== undefined && object.maxDepth !== null) {\n      message.maxDepth = Number(object.maxDepth);\n    } else {\n      message.maxDepth = 0;\n    }\n\n    if (object.minDepth !== undefined && object.minDepth !== null) {\n      message.minDepth = Number(object.minDepth);\n    } else {\n      message.minDepth = 0;\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.leafSpec !== undefined && (obj.leafSpec = message.leafSpec ? exports.LeafOp.toJSON(message.leafSpec) : undefined);\n    message.innerSpec !== undefined && (obj.innerSpec = message.innerSpec ? exports.InnerSpec.toJSON(message.innerSpec) : undefined);\n    message.maxDepth !== undefined && (obj.maxDepth = message.maxDepth);\n    message.minDepth !== undefined && (obj.minDepth = message.minDepth);\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseProofSpec);\n\n    if (object.leafSpec !== undefined && object.leafSpec !== null) {\n      message.leafSpec = exports.LeafOp.fromPartial(object.leafSpec);\n    } else {\n      message.leafSpec = undefined;\n    }\n\n    if (object.innerSpec !== undefined && object.innerSpec !== null) {\n      message.innerSpec = exports.InnerSpec.fromPartial(object.innerSpec);\n    } else {\n      message.innerSpec = undefined;\n    }\n\n    if (object.maxDepth !== undefined && object.maxDepth !== null) {\n      message.maxDepth = object.maxDepth;\n    } else {\n      message.maxDepth = 0;\n    }\n\n    if (object.minDepth !== undefined && object.minDepth !== null) {\n      message.minDepth = object.minDepth;\n    } else {\n      message.minDepth = 0;\n    }\n\n    return message;\n  }\n\n};\nconst baseInnerSpec = {\n  childOrder: 0,\n  childSize: 0,\n  minPrefixLength: 0,\n  maxPrefixLength: 0,\n  hash: 0\n};\nexports.InnerSpec = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    writer.uint32(10).fork();\n\n    for (const v of message.childOrder) {\n      writer.int32(v);\n    }\n\n    writer.ldelim();\n\n    if (message.childSize !== 0) {\n      writer.uint32(16).int32(message.childSize);\n    }\n\n    if (message.minPrefixLength !== 0) {\n      writer.uint32(24).int32(message.minPrefixLength);\n    }\n\n    if (message.maxPrefixLength !== 0) {\n      writer.uint32(32).int32(message.maxPrefixLength);\n    }\n\n    if (message.emptyChild.length !== 0) {\n      writer.uint32(42).bytes(message.emptyChild);\n    }\n\n    if (message.hash !== 0) {\n      writer.uint32(48).int32(message.hash);\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseInnerSpec);\n    message.childOrder = [];\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if ((tag & 7) === 2) {\n            const end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) {\n              message.childOrder.push(reader.int32());\n            }\n          } else {\n            message.childOrder.push(reader.int32());\n          }\n\n          break;\n\n        case 2:\n          message.childSize = reader.int32();\n          break;\n\n        case 3:\n          message.minPrefixLength = reader.int32();\n          break;\n\n        case 4:\n          message.maxPrefixLength = reader.int32();\n          break;\n\n        case 5:\n          message.emptyChild = reader.bytes();\n          break;\n\n        case 6:\n          message.hash = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseInnerSpec);\n    message.childOrder = [];\n\n    if (object.childOrder !== undefined && object.childOrder !== null) {\n      for (const e of object.childOrder) {\n        message.childOrder.push(Number(e));\n      }\n    }\n\n    if (object.childSize !== undefined && object.childSize !== null) {\n      message.childSize = Number(object.childSize);\n    } else {\n      message.childSize = 0;\n    }\n\n    if (object.minPrefixLength !== undefined && object.minPrefixLength !== null) {\n      message.minPrefixLength = Number(object.minPrefixLength);\n    } else {\n      message.minPrefixLength = 0;\n    }\n\n    if (object.maxPrefixLength !== undefined && object.maxPrefixLength !== null) {\n      message.maxPrefixLength = Number(object.maxPrefixLength);\n    } else {\n      message.maxPrefixLength = 0;\n    }\n\n    if (object.emptyChild !== undefined && object.emptyChild !== null) {\n      message.emptyChild = bytesFromBase64(object.emptyChild);\n    }\n\n    if (object.hash !== undefined && object.hash !== null) {\n      message.hash = hashOpFromJSON(object.hash);\n    } else {\n      message.hash = 0;\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n\n    if (message.childOrder) {\n      obj.childOrder = message.childOrder.map(e => e);\n    } else {\n      obj.childOrder = [];\n    }\n\n    message.childSize !== undefined && (obj.childSize = message.childSize);\n    message.minPrefixLength !== undefined && (obj.minPrefixLength = message.minPrefixLength);\n    message.maxPrefixLength !== undefined && (obj.maxPrefixLength = message.maxPrefixLength);\n    message.emptyChild !== undefined && (obj.emptyChild = base64FromBytes(message.emptyChild !== undefined ? message.emptyChild : new Uint8Array()));\n    message.hash !== undefined && (obj.hash = hashOpToJSON(message.hash));\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseInnerSpec);\n    message.childOrder = [];\n\n    if (object.childOrder !== undefined && object.childOrder !== null) {\n      for (const e of object.childOrder) {\n        message.childOrder.push(e);\n      }\n    }\n\n    if (object.childSize !== undefined && object.childSize !== null) {\n      message.childSize = object.childSize;\n    } else {\n      message.childSize = 0;\n    }\n\n    if (object.minPrefixLength !== undefined && object.minPrefixLength !== null) {\n      message.minPrefixLength = object.minPrefixLength;\n    } else {\n      message.minPrefixLength = 0;\n    }\n\n    if (object.maxPrefixLength !== undefined && object.maxPrefixLength !== null) {\n      message.maxPrefixLength = object.maxPrefixLength;\n    } else {\n      message.maxPrefixLength = 0;\n    }\n\n    if (object.emptyChild !== undefined && object.emptyChild !== null) {\n      message.emptyChild = object.emptyChild;\n    } else {\n      message.emptyChild = new Uint8Array();\n    }\n\n    if (object.hash !== undefined && object.hash !== null) {\n      message.hash = object.hash;\n    } else {\n      message.hash = 0;\n    }\n\n    return message;\n  }\n\n};\nconst baseBatchProof = {};\nexports.BatchProof = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    for (const v of message.entries) {\n      exports.BatchEntry.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseBatchProof);\n    message.entries = [];\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.entries.push(exports.BatchEntry.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseBatchProof);\n    message.entries = [];\n\n    if (object.entries !== undefined && object.entries !== null) {\n      for (const e of object.entries) {\n        message.entries.push(exports.BatchEntry.fromJSON(e));\n      }\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n\n    if (message.entries) {\n      obj.entries = message.entries.map(e => e ? exports.BatchEntry.toJSON(e) : undefined);\n    } else {\n      obj.entries = [];\n    }\n\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseBatchProof);\n    message.entries = [];\n\n    if (object.entries !== undefined && object.entries !== null) {\n      for (const e of object.entries) {\n        message.entries.push(exports.BatchEntry.fromPartial(e));\n      }\n    }\n\n    return message;\n  }\n\n};\nconst baseBatchEntry = {};\nexports.BatchEntry = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.exist !== undefined) {\n      exports.ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();\n    }\n\n    if (message.nonexist !== undefined) {\n      exports.NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseBatchEntry);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.exist = exports.ExistenceProof.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          message.nonexist = exports.NonExistenceProof.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseBatchEntry);\n\n    if (object.exist !== undefined && object.exist !== null) {\n      message.exist = exports.ExistenceProof.fromJSON(object.exist);\n    } else {\n      message.exist = undefined;\n    }\n\n    if (object.nonexist !== undefined && object.nonexist !== null) {\n      message.nonexist = exports.NonExistenceProof.fromJSON(object.nonexist);\n    } else {\n      message.nonexist = undefined;\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.exist !== undefined && (obj.exist = message.exist ? exports.ExistenceProof.toJSON(message.exist) : undefined);\n    message.nonexist !== undefined && (obj.nonexist = message.nonexist ? exports.NonExistenceProof.toJSON(message.nonexist) : undefined);\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseBatchEntry);\n\n    if (object.exist !== undefined && object.exist !== null) {\n      message.exist = exports.ExistenceProof.fromPartial(object.exist);\n    } else {\n      message.exist = undefined;\n    }\n\n    if (object.nonexist !== undefined && object.nonexist !== null) {\n      message.nonexist = exports.NonExistenceProof.fromPartial(object.nonexist);\n    } else {\n      message.nonexist = undefined;\n    }\n\n    return message;\n  }\n\n};\nconst baseCompressedBatchProof = {};\nexports.CompressedBatchProof = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    for (const v of message.entries) {\n      exports.CompressedBatchEntry.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n\n    for (const v of message.lookupInners) {\n      exports.InnerOp.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseCompressedBatchProof);\n    message.entries = [];\n    message.lookupInners = [];\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.entries.push(exports.CompressedBatchEntry.decode(reader, reader.uint32()));\n          break;\n\n        case 2:\n          message.lookupInners.push(exports.InnerOp.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseCompressedBatchProof);\n    message.entries = [];\n    message.lookupInners = [];\n\n    if (object.entries !== undefined && object.entries !== null) {\n      for (const e of object.entries) {\n        message.entries.push(exports.CompressedBatchEntry.fromJSON(e));\n      }\n    }\n\n    if (object.lookupInners !== undefined && object.lookupInners !== null) {\n      for (const e of object.lookupInners) {\n        message.lookupInners.push(exports.InnerOp.fromJSON(e));\n      }\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n\n    if (message.entries) {\n      obj.entries = message.entries.map(e => e ? exports.CompressedBatchEntry.toJSON(e) : undefined);\n    } else {\n      obj.entries = [];\n    }\n\n    if (message.lookupInners) {\n      obj.lookupInners = message.lookupInners.map(e => e ? exports.InnerOp.toJSON(e) : undefined);\n    } else {\n      obj.lookupInners = [];\n    }\n\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseCompressedBatchProof);\n    message.entries = [];\n    message.lookupInners = [];\n\n    if (object.entries !== undefined && object.entries !== null) {\n      for (const e of object.entries) {\n        message.entries.push(exports.CompressedBatchEntry.fromPartial(e));\n      }\n    }\n\n    if (object.lookupInners !== undefined && object.lookupInners !== null) {\n      for (const e of object.lookupInners) {\n        message.lookupInners.push(exports.InnerOp.fromPartial(e));\n      }\n    }\n\n    return message;\n  }\n\n};\nconst baseCompressedBatchEntry = {};\nexports.CompressedBatchEntry = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.exist !== undefined) {\n      exports.CompressedExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();\n    }\n\n    if (message.nonexist !== undefined) {\n      exports.CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseCompressedBatchEntry);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.exist = exports.CompressedExistenceProof.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          message.nonexist = exports.CompressedNonExistenceProof.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseCompressedBatchEntry);\n\n    if (object.exist !== undefined && object.exist !== null) {\n      message.exist = exports.CompressedExistenceProof.fromJSON(object.exist);\n    } else {\n      message.exist = undefined;\n    }\n\n    if (object.nonexist !== undefined && object.nonexist !== null) {\n      message.nonexist = exports.CompressedNonExistenceProof.fromJSON(object.nonexist);\n    } else {\n      message.nonexist = undefined;\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.exist !== undefined && (obj.exist = message.exist ? exports.CompressedExistenceProof.toJSON(message.exist) : undefined);\n    message.nonexist !== undefined && (obj.nonexist = message.nonexist ? exports.CompressedNonExistenceProof.toJSON(message.nonexist) : undefined);\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseCompressedBatchEntry);\n\n    if (object.exist !== undefined && object.exist !== null) {\n      message.exist = exports.CompressedExistenceProof.fromPartial(object.exist);\n    } else {\n      message.exist = undefined;\n    }\n\n    if (object.nonexist !== undefined && object.nonexist !== null) {\n      message.nonexist = exports.CompressedNonExistenceProof.fromPartial(object.nonexist);\n    } else {\n      message.nonexist = undefined;\n    }\n\n    return message;\n  }\n\n};\nconst baseCompressedExistenceProof = {\n  path: 0\n};\nexports.CompressedExistenceProof = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n\n    if (message.value.length !== 0) {\n      writer.uint32(18).bytes(message.value);\n    }\n\n    if (message.leaf !== undefined) {\n      exports.LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();\n    }\n\n    writer.uint32(34).fork();\n\n    for (const v of message.path) {\n      writer.int32(v);\n    }\n\n    writer.ldelim();\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseCompressedExistenceProof);\n    message.path = [];\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n\n        case 2:\n          message.value = reader.bytes();\n          break;\n\n        case 3:\n          message.leaf = exports.LeafOp.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          if ((tag & 7) === 2) {\n            const end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) {\n              message.path.push(reader.int32());\n            }\n          } else {\n            message.path.push(reader.int32());\n          }\n\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseCompressedExistenceProof);\n    message.path = [];\n\n    if (object.key !== undefined && object.key !== null) {\n      message.key = bytesFromBase64(object.key);\n    }\n\n    if (object.value !== undefined && object.value !== null) {\n      message.value = bytesFromBase64(object.value);\n    }\n\n    if (object.leaf !== undefined && object.leaf !== null) {\n      message.leaf = exports.LeafOp.fromJSON(object.leaf);\n    } else {\n      message.leaf = undefined;\n    }\n\n    if (object.path !== undefined && object.path !== null) {\n      for (const e of object.path) {\n        message.path.push(Number(e));\n      }\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.key !== undefined && (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));\n    message.value !== undefined && (obj.value = base64FromBytes(message.value !== undefined ? message.value : new Uint8Array()));\n    message.leaf !== undefined && (obj.leaf = message.leaf ? exports.LeafOp.toJSON(message.leaf) : undefined);\n\n    if (message.path) {\n      obj.path = message.path.map(e => e);\n    } else {\n      obj.path = [];\n    }\n\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseCompressedExistenceProof);\n    message.path = [];\n\n    if (object.key !== undefined && object.key !== null) {\n      message.key = object.key;\n    } else {\n      message.key = new Uint8Array();\n    }\n\n    if (object.value !== undefined && object.value !== null) {\n      message.value = object.value;\n    } else {\n      message.value = new Uint8Array();\n    }\n\n    if (object.leaf !== undefined && object.leaf !== null) {\n      message.leaf = exports.LeafOp.fromPartial(object.leaf);\n    } else {\n      message.leaf = undefined;\n    }\n\n    if (object.path !== undefined && object.path !== null) {\n      for (const e of object.path) {\n        message.path.push(e);\n      }\n    }\n\n    return message;\n  }\n\n};\nconst baseCompressedNonExistenceProof = {};\nexports.CompressedNonExistenceProof = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n\n    if (message.left !== undefined) {\n      exports.CompressedExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();\n    }\n\n    if (message.right !== undefined) {\n      exports.CompressedExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseCompressedNonExistenceProof);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n\n        case 2:\n          message.left = exports.CompressedExistenceProof.decode(reader, reader.uint32());\n          break;\n\n        case 3:\n          message.right = exports.CompressedExistenceProof.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseCompressedNonExistenceProof);\n\n    if (object.key !== undefined && object.key !== null) {\n      message.key = bytesFromBase64(object.key);\n    }\n\n    if (object.left !== undefined && object.left !== null) {\n      message.left = exports.CompressedExistenceProof.fromJSON(object.left);\n    } else {\n      message.left = undefined;\n    }\n\n    if (object.right !== undefined && object.right !== null) {\n      message.right = exports.CompressedExistenceProof.fromJSON(object.right);\n    } else {\n      message.right = undefined;\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.key !== undefined && (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));\n    message.left !== undefined && (obj.left = message.left ? exports.CompressedExistenceProof.toJSON(message.left) : undefined);\n    message.right !== undefined && (obj.right = message.right ? exports.CompressedExistenceProof.toJSON(message.right) : undefined);\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseCompressedNonExistenceProof);\n\n    if (object.key !== undefined && object.key !== null) {\n      message.key = object.key;\n    } else {\n      message.key = new Uint8Array();\n    }\n\n    if (object.left !== undefined && object.left !== null) {\n      message.left = exports.CompressedExistenceProof.fromPartial(object.left);\n    } else {\n      message.left = undefined;\n    }\n\n    if (object.right !== undefined && object.right !== null) {\n      message.right = exports.CompressedExistenceProof.fromPartial(object.right);\n    } else {\n      message.right = undefined;\n    }\n\n    return message;\n  }\n\n};\n\nvar globalThis = (() => {\n  if (typeof globalThis !== 'undefined') return globalThis;\n  if (typeof self !== 'undefined') return self;\n  if (typeof window !== 'undefined') return window;\n  if (typeof global !== 'undefined') return global;\n  throw 'Unable to locate global object';\n})();\n\nconst atob = globalThis.atob || (b64 => globalThis.Buffer.from(b64, 'base64').toString('binary'));\n\nfunction bytesFromBase64(b64) {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n\n  return arr;\n}\n\nconst btoa = globalThis.btoa || (bin => globalThis.Buffer.from(bin, 'binary').toString('base64'));\n\nfunction base64FromBytes(arr) {\n  const bin = [];\n\n  for (let i = 0; i < arr.byteLength; ++i) {\n    bin.push(String.fromCharCode(arr[i]));\n  }\n\n  return btoa(bin.join(''));\n}","map":{"version":3,"sources":["../../../src/codec/confio/proofs.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CompressedNonExistenceProof = exports.CompressedExistenceProof = exports.CompressedBatchEntry = exports.CompressedBatchProof = exports.BatchEntry = exports.BatchProof = exports.InnerSpec = exports.ProofSpec = exports.InnerOp = exports.LeafOp = exports.CommitmentProof = exports.NonExistenceProof = exports.ExistenceProof = exports.lengthOpToJSON = exports.lengthOpFromJSON = exports.LengthOp = exports.hashOpToJSON = exports.hashOpFromJSON = exports.HashOp = exports.protobufPackage = void 0;\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nexports.protobufPackage = 'ics23';\nvar HashOp;\n(function (HashOp) {\n    /** NO_HASH - NO_HASH is the default if no data passed. Note this is an illegal argument some places. */\n    HashOp[HashOp[\"NO_HASH\"] = 0] = \"NO_HASH\";\n    HashOp[HashOp[\"SHA256\"] = 1] = \"SHA256\";\n    HashOp[HashOp[\"SHA512\"] = 2] = \"SHA512\";\n    HashOp[HashOp[\"KECCAK\"] = 3] = \"KECCAK\";\n    HashOp[HashOp[\"RIPEMD160\"] = 4] = \"RIPEMD160\";\n    /** BITCOIN - ripemd160(sha256(x)) */\n    HashOp[HashOp[\"BITCOIN\"] = 5] = \"BITCOIN\";\n    HashOp[HashOp[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(HashOp = exports.HashOp || (exports.HashOp = {}));\nfunction hashOpFromJSON(object) {\n    switch (object) {\n        case 0:\n        case 'NO_HASH':\n            return HashOp.NO_HASH;\n        case 1:\n        case 'SHA256':\n            return HashOp.SHA256;\n        case 2:\n        case 'SHA512':\n            return HashOp.SHA512;\n        case 3:\n        case 'KECCAK':\n            return HashOp.KECCAK;\n        case 4:\n        case 'RIPEMD160':\n            return HashOp.RIPEMD160;\n        case 5:\n        case 'BITCOIN':\n            return HashOp.BITCOIN;\n        case -1:\n        case 'UNRECOGNIZED':\n        default:\n            return HashOp.UNRECOGNIZED;\n    }\n}\nexports.hashOpFromJSON = hashOpFromJSON;\nfunction hashOpToJSON(object) {\n    switch (object) {\n        case HashOp.NO_HASH:\n            return 'NO_HASH';\n        case HashOp.SHA256:\n            return 'SHA256';\n        case HashOp.SHA512:\n            return 'SHA512';\n        case HashOp.KECCAK:\n            return 'KECCAK';\n        case HashOp.RIPEMD160:\n            return 'RIPEMD160';\n        case HashOp.BITCOIN:\n            return 'BITCOIN';\n        default:\n            return 'UNKNOWN';\n    }\n}\nexports.hashOpToJSON = hashOpToJSON;\n/**\n * LengthOp defines how to process the key and value of the LeafOp\n * to include length information. After encoding the length with the given\n * algorithm, the length will be prepended to the key and value bytes.\n * (Each one with it's own encoded length)\n */\nvar LengthOp;\n(function (LengthOp) {\n    /** NO_PREFIX - NO_PREFIX don't include any length info */\n    LengthOp[LengthOp[\"NO_PREFIX\"] = 0] = \"NO_PREFIX\";\n    /** VAR_PROTO - VAR_PROTO uses protobuf (and go-amino) varint encoding of the length */\n    LengthOp[LengthOp[\"VAR_PROTO\"] = 1] = \"VAR_PROTO\";\n    /** VAR_RLP - VAR_RLP uses rlp int encoding of the length */\n    LengthOp[LengthOp[\"VAR_RLP\"] = 2] = \"VAR_RLP\";\n    /** FIXED32_BIG - FIXED32_BIG uses big-endian encoding of the length as a 32 bit integer */\n    LengthOp[LengthOp[\"FIXED32_BIG\"] = 3] = \"FIXED32_BIG\";\n    /** FIXED32_LITTLE - FIXED32_LITTLE uses little-endian encoding of the length as a 32 bit integer */\n    LengthOp[LengthOp[\"FIXED32_LITTLE\"] = 4] = \"FIXED32_LITTLE\";\n    /** FIXED64_BIG - FIXED64_BIG uses big-endian encoding of the length as a 64 bit integer */\n    LengthOp[LengthOp[\"FIXED64_BIG\"] = 5] = \"FIXED64_BIG\";\n    /** FIXED64_LITTLE - FIXED64_LITTLE uses little-endian encoding of the length as a 64 bit integer */\n    LengthOp[LengthOp[\"FIXED64_LITTLE\"] = 6] = \"FIXED64_LITTLE\";\n    /** REQUIRE_32_BYTES - REQUIRE_32_BYTES is like NONE, but will fail if the input is not exactly 32 bytes (sha256 output) */\n    LengthOp[LengthOp[\"REQUIRE_32_BYTES\"] = 7] = \"REQUIRE_32_BYTES\";\n    /** REQUIRE_64_BYTES - REQUIRE_64_BYTES is like NONE, but will fail if the input is not exactly 64 bytes (sha512 output) */\n    LengthOp[LengthOp[\"REQUIRE_64_BYTES\"] = 8] = \"REQUIRE_64_BYTES\";\n    LengthOp[LengthOp[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(LengthOp = exports.LengthOp || (exports.LengthOp = {}));\nfunction lengthOpFromJSON(object) {\n    switch (object) {\n        case 0:\n        case 'NO_PREFIX':\n            return LengthOp.NO_PREFIX;\n        case 1:\n        case 'VAR_PROTO':\n            return LengthOp.VAR_PROTO;\n        case 2:\n        case 'VAR_RLP':\n            return LengthOp.VAR_RLP;\n        case 3:\n        case 'FIXED32_BIG':\n            return LengthOp.FIXED32_BIG;\n        case 4:\n        case 'FIXED32_LITTLE':\n            return LengthOp.FIXED32_LITTLE;\n        case 5:\n        case 'FIXED64_BIG':\n            return LengthOp.FIXED64_BIG;\n        case 6:\n        case 'FIXED64_LITTLE':\n            return LengthOp.FIXED64_LITTLE;\n        case 7:\n        case 'REQUIRE_32_BYTES':\n            return LengthOp.REQUIRE_32_BYTES;\n        case 8:\n        case 'REQUIRE_64_BYTES':\n            return LengthOp.REQUIRE_64_BYTES;\n        case -1:\n        case 'UNRECOGNIZED':\n        default:\n            return LengthOp.UNRECOGNIZED;\n    }\n}\nexports.lengthOpFromJSON = lengthOpFromJSON;\nfunction lengthOpToJSON(object) {\n    switch (object) {\n        case LengthOp.NO_PREFIX:\n            return 'NO_PREFIX';\n        case LengthOp.VAR_PROTO:\n            return 'VAR_PROTO';\n        case LengthOp.VAR_RLP:\n            return 'VAR_RLP';\n        case LengthOp.FIXED32_BIG:\n            return 'FIXED32_BIG';\n        case LengthOp.FIXED32_LITTLE:\n            return 'FIXED32_LITTLE';\n        case LengthOp.FIXED64_BIG:\n            return 'FIXED64_BIG';\n        case LengthOp.FIXED64_LITTLE:\n            return 'FIXED64_LITTLE';\n        case LengthOp.REQUIRE_32_BYTES:\n            return 'REQUIRE_32_BYTES';\n        case LengthOp.REQUIRE_64_BYTES:\n            return 'REQUIRE_64_BYTES';\n        default:\n            return 'UNKNOWN';\n    }\n}\nexports.lengthOpToJSON = lengthOpToJSON;\nconst baseExistenceProof = {};\nexports.ExistenceProof = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.key.length !== 0) {\n            writer.uint32(10).bytes(message.key);\n        }\n        if (message.value.length !== 0) {\n            writer.uint32(18).bytes(message.value);\n        }\n        if (message.leaf !== undefined) {\n            exports.LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();\n        }\n        for (const v of message.path) {\n            exports.InnerOp.encode(v, writer.uint32(34).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseExistenceProof);\n        message.path = [];\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.value = reader.bytes();\n                    break;\n                case 3:\n                    message.leaf = exports.LeafOp.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.path.push(exports.InnerOp.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseExistenceProof);\n        message.path = [];\n        if (object.key !== undefined && object.key !== null) {\n            message.key = bytesFromBase64(object.key);\n        }\n        if (object.value !== undefined && object.value !== null) {\n            message.value = bytesFromBase64(object.value);\n        }\n        if (object.leaf !== undefined && object.leaf !== null) {\n            message.leaf = exports.LeafOp.fromJSON(object.leaf);\n        }\n        else {\n            message.leaf = undefined;\n        }\n        if (object.path !== undefined && object.path !== null) {\n            for (const e of object.path) {\n                message.path.push(exports.InnerOp.fromJSON(e));\n            }\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined &&\n            (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));\n        message.value !== undefined &&\n            (obj.value = base64FromBytes(message.value !== undefined ? message.value : new Uint8Array()));\n        message.leaf !== undefined &&\n            (obj.leaf = message.leaf ? exports.LeafOp.toJSON(message.leaf) : undefined);\n        if (message.path) {\n            obj.path = message.path.map((e) => (e ? exports.InnerOp.toJSON(e) : undefined));\n        }\n        else {\n            obj.path = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseExistenceProof);\n        message.path = [];\n        if (object.key !== undefined && object.key !== null) {\n            message.key = object.key;\n        }\n        else {\n            message.key = new Uint8Array();\n        }\n        if (object.value !== undefined && object.value !== null) {\n            message.value = object.value;\n        }\n        else {\n            message.value = new Uint8Array();\n        }\n        if (object.leaf !== undefined && object.leaf !== null) {\n            message.leaf = exports.LeafOp.fromPartial(object.leaf);\n        }\n        else {\n            message.leaf = undefined;\n        }\n        if (object.path !== undefined && object.path !== null) {\n            for (const e of object.path) {\n                message.path.push(exports.InnerOp.fromPartial(e));\n            }\n        }\n        return message;\n    },\n};\nconst baseNonExistenceProof = {};\nexports.NonExistenceProof = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.key.length !== 0) {\n            writer.uint32(10).bytes(message.key);\n        }\n        if (message.left !== undefined) {\n            exports.ExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.right !== undefined) {\n            exports.ExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseNonExistenceProof);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.left = exports.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.right = exports.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseNonExistenceProof);\n        if (object.key !== undefined && object.key !== null) {\n            message.key = bytesFromBase64(object.key);\n        }\n        if (object.left !== undefined && object.left !== null) {\n            message.left = exports.ExistenceProof.fromJSON(object.left);\n        }\n        else {\n            message.left = undefined;\n        }\n        if (object.right !== undefined && object.right !== null) {\n            message.right = exports.ExistenceProof.fromJSON(object.right);\n        }\n        else {\n            message.right = undefined;\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined &&\n            (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));\n        message.left !== undefined &&\n            (obj.left = message.left\n                ? exports.ExistenceProof.toJSON(message.left)\n                : undefined);\n        message.right !== undefined &&\n            (obj.right = message.right\n                ? exports.ExistenceProof.toJSON(message.right)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseNonExistenceProof);\n        if (object.key !== undefined && object.key !== null) {\n            message.key = object.key;\n        }\n        else {\n            message.key = new Uint8Array();\n        }\n        if (object.left !== undefined && object.left !== null) {\n            message.left = exports.ExistenceProof.fromPartial(object.left);\n        }\n        else {\n            message.left = undefined;\n        }\n        if (object.right !== undefined && object.right !== null) {\n            message.right = exports.ExistenceProof.fromPartial(object.right);\n        }\n        else {\n            message.right = undefined;\n        }\n        return message;\n    },\n};\nconst baseCommitmentProof = {};\nexports.CommitmentProof = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.exist !== undefined) {\n            exports.ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.nonexist !== undefined) {\n            exports.NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.batch !== undefined) {\n            exports.BatchProof.encode(message.batch, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.compressed !== undefined) {\n            exports.CompressedBatchProof.encode(message.compressed, writer.uint32(34).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseCommitmentProof);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.exist = exports.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.nonexist = exports.NonExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.batch = exports.BatchProof.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.compressed = exports.CompressedBatchProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseCommitmentProof);\n        if (object.exist !== undefined && object.exist !== null) {\n            message.exist = exports.ExistenceProof.fromJSON(object.exist);\n        }\n        else {\n            message.exist = undefined;\n        }\n        if (object.nonexist !== undefined && object.nonexist !== null) {\n            message.nonexist = exports.NonExistenceProof.fromJSON(object.nonexist);\n        }\n        else {\n            message.nonexist = undefined;\n        }\n        if (object.batch !== undefined && object.batch !== null) {\n            message.batch = exports.BatchProof.fromJSON(object.batch);\n        }\n        else {\n            message.batch = undefined;\n        }\n        if (object.compressed !== undefined && object.compressed !== null) {\n            message.compressed = exports.CompressedBatchProof.fromJSON(object.compressed);\n        }\n        else {\n            message.compressed = undefined;\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.exist !== undefined &&\n            (obj.exist = message.exist\n                ? exports.ExistenceProof.toJSON(message.exist)\n                : undefined);\n        message.nonexist !== undefined &&\n            (obj.nonexist = message.nonexist\n                ? exports.NonExistenceProof.toJSON(message.nonexist)\n                : undefined);\n        message.batch !== undefined &&\n            (obj.batch = message.batch\n                ? exports.BatchProof.toJSON(message.batch)\n                : undefined);\n        message.compressed !== undefined &&\n            (obj.compressed = message.compressed\n                ? exports.CompressedBatchProof.toJSON(message.compressed)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseCommitmentProof);\n        if (object.exist !== undefined && object.exist !== null) {\n            message.exist = exports.ExistenceProof.fromPartial(object.exist);\n        }\n        else {\n            message.exist = undefined;\n        }\n        if (object.nonexist !== undefined && object.nonexist !== null) {\n            message.nonexist = exports.NonExistenceProof.fromPartial(object.nonexist);\n        }\n        else {\n            message.nonexist = undefined;\n        }\n        if (object.batch !== undefined && object.batch !== null) {\n            message.batch = exports.BatchProof.fromPartial(object.batch);\n        }\n        else {\n            message.batch = undefined;\n        }\n        if (object.compressed !== undefined && object.compressed !== null) {\n            message.compressed = exports.CompressedBatchProof.fromPartial(object.compressed);\n        }\n        else {\n            message.compressed = undefined;\n        }\n        return message;\n    },\n};\nconst baseLeafOp = {\n    hash: 0,\n    prehashKey: 0,\n    prehashValue: 0,\n    length: 0,\n};\nexports.LeafOp = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.hash !== 0) {\n            writer.uint32(8).int32(message.hash);\n        }\n        if (message.prehashKey !== 0) {\n            writer.uint32(16).int32(message.prehashKey);\n        }\n        if (message.prehashValue !== 0) {\n            writer.uint32(24).int32(message.prehashValue);\n        }\n        if (message.length !== 0) {\n            writer.uint32(32).int32(message.length);\n        }\n        if (message.prefix.length !== 0) {\n            writer.uint32(42).bytes(message.prefix);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseLeafOp);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.hash = reader.int32();\n                    break;\n                case 2:\n                    message.prehashKey = reader.int32();\n                    break;\n                case 3:\n                    message.prehashValue = reader.int32();\n                    break;\n                case 4:\n                    message.length = reader.int32();\n                    break;\n                case 5:\n                    message.prefix = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseLeafOp);\n        if (object.hash !== undefined && object.hash !== null) {\n            message.hash = hashOpFromJSON(object.hash);\n        }\n        else {\n            message.hash = 0;\n        }\n        if (object.prehashKey !== undefined && object.prehashKey !== null) {\n            message.prehashKey = hashOpFromJSON(object.prehashKey);\n        }\n        else {\n            message.prehashKey = 0;\n        }\n        if (object.prehashValue !== undefined && object.prehashValue !== null) {\n            message.prehashValue = hashOpFromJSON(object.prehashValue);\n        }\n        else {\n            message.prehashValue = 0;\n        }\n        if (object.length !== undefined && object.length !== null) {\n            message.length = lengthOpFromJSON(object.length);\n        }\n        else {\n            message.length = 0;\n        }\n        if (object.prefix !== undefined && object.prefix !== null) {\n            message.prefix = bytesFromBase64(object.prefix);\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.hash !== undefined && (obj.hash = hashOpToJSON(message.hash));\n        message.prehashKey !== undefined &&\n            (obj.prehashKey = hashOpToJSON(message.prehashKey));\n        message.prehashValue !== undefined &&\n            (obj.prehashValue = hashOpToJSON(message.prehashValue));\n        message.length !== undefined &&\n            (obj.length = lengthOpToJSON(message.length));\n        message.prefix !== undefined &&\n            (obj.prefix = base64FromBytes(message.prefix !== undefined ? message.prefix : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseLeafOp);\n        if (object.hash !== undefined && object.hash !== null) {\n            message.hash = object.hash;\n        }\n        else {\n            message.hash = 0;\n        }\n        if (object.prehashKey !== undefined && object.prehashKey !== null) {\n            message.prehashKey = object.prehashKey;\n        }\n        else {\n            message.prehashKey = 0;\n        }\n        if (object.prehashValue !== undefined && object.prehashValue !== null) {\n            message.prehashValue = object.prehashValue;\n        }\n        else {\n            message.prehashValue = 0;\n        }\n        if (object.length !== undefined && object.length !== null) {\n            message.length = object.length;\n        }\n        else {\n            message.length = 0;\n        }\n        if (object.prefix !== undefined && object.prefix !== null) {\n            message.prefix = object.prefix;\n        }\n        else {\n            message.prefix = new Uint8Array();\n        }\n        return message;\n    },\n};\nconst baseInnerOp = { hash: 0 };\nexports.InnerOp = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.hash !== 0) {\n            writer.uint32(8).int32(message.hash);\n        }\n        if (message.prefix.length !== 0) {\n            writer.uint32(18).bytes(message.prefix);\n        }\n        if (message.suffix.length !== 0) {\n            writer.uint32(26).bytes(message.suffix);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseInnerOp);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.hash = reader.int32();\n                    break;\n                case 2:\n                    message.prefix = reader.bytes();\n                    break;\n                case 3:\n                    message.suffix = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseInnerOp);\n        if (object.hash !== undefined && object.hash !== null) {\n            message.hash = hashOpFromJSON(object.hash);\n        }\n        else {\n            message.hash = 0;\n        }\n        if (object.prefix !== undefined && object.prefix !== null) {\n            message.prefix = bytesFromBase64(object.prefix);\n        }\n        if (object.suffix !== undefined && object.suffix !== null) {\n            message.suffix = bytesFromBase64(object.suffix);\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.hash !== undefined && (obj.hash = hashOpToJSON(message.hash));\n        message.prefix !== undefined &&\n            (obj.prefix = base64FromBytes(message.prefix !== undefined ? message.prefix : new Uint8Array()));\n        message.suffix !== undefined &&\n            (obj.suffix = base64FromBytes(message.suffix !== undefined ? message.suffix : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseInnerOp);\n        if (object.hash !== undefined && object.hash !== null) {\n            message.hash = object.hash;\n        }\n        else {\n            message.hash = 0;\n        }\n        if (object.prefix !== undefined && object.prefix !== null) {\n            message.prefix = object.prefix;\n        }\n        else {\n            message.prefix = new Uint8Array();\n        }\n        if (object.suffix !== undefined && object.suffix !== null) {\n            message.suffix = object.suffix;\n        }\n        else {\n            message.suffix = new Uint8Array();\n        }\n        return message;\n    },\n};\nconst baseProofSpec = { maxDepth: 0, minDepth: 0 };\nexports.ProofSpec = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.leafSpec !== undefined) {\n            exports.LeafOp.encode(message.leafSpec, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.innerSpec !== undefined) {\n            exports.InnerSpec.encode(message.innerSpec, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.maxDepth !== 0) {\n            writer.uint32(24).int32(message.maxDepth);\n        }\n        if (message.minDepth !== 0) {\n            writer.uint32(32).int32(message.minDepth);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseProofSpec);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.leafSpec = exports.LeafOp.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.innerSpec = exports.InnerSpec.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.maxDepth = reader.int32();\n                    break;\n                case 4:\n                    message.minDepth = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseProofSpec);\n        if (object.leafSpec !== undefined && object.leafSpec !== null) {\n            message.leafSpec = exports.LeafOp.fromJSON(object.leafSpec);\n        }\n        else {\n            message.leafSpec = undefined;\n        }\n        if (object.innerSpec !== undefined && object.innerSpec !== null) {\n            message.innerSpec = exports.InnerSpec.fromJSON(object.innerSpec);\n        }\n        else {\n            message.innerSpec = undefined;\n        }\n        if (object.maxDepth !== undefined && object.maxDepth !== null) {\n            message.maxDepth = Number(object.maxDepth);\n        }\n        else {\n            message.maxDepth = 0;\n        }\n        if (object.minDepth !== undefined && object.minDepth !== null) {\n            message.minDepth = Number(object.minDepth);\n        }\n        else {\n            message.minDepth = 0;\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.leafSpec !== undefined &&\n            (obj.leafSpec = message.leafSpec\n                ? exports.LeafOp.toJSON(message.leafSpec)\n                : undefined);\n        message.innerSpec !== undefined &&\n            (obj.innerSpec = message.innerSpec\n                ? exports.InnerSpec.toJSON(message.innerSpec)\n                : undefined);\n        message.maxDepth !== undefined && (obj.maxDepth = message.maxDepth);\n        message.minDepth !== undefined && (obj.minDepth = message.minDepth);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseProofSpec);\n        if (object.leafSpec !== undefined && object.leafSpec !== null) {\n            message.leafSpec = exports.LeafOp.fromPartial(object.leafSpec);\n        }\n        else {\n            message.leafSpec = undefined;\n        }\n        if (object.innerSpec !== undefined && object.innerSpec !== null) {\n            message.innerSpec = exports.InnerSpec.fromPartial(object.innerSpec);\n        }\n        else {\n            message.innerSpec = undefined;\n        }\n        if (object.maxDepth !== undefined && object.maxDepth !== null) {\n            message.maxDepth = object.maxDepth;\n        }\n        else {\n            message.maxDepth = 0;\n        }\n        if (object.minDepth !== undefined && object.minDepth !== null) {\n            message.minDepth = object.minDepth;\n        }\n        else {\n            message.minDepth = 0;\n        }\n        return message;\n    },\n};\nconst baseInnerSpec = {\n    childOrder: 0,\n    childSize: 0,\n    minPrefixLength: 0,\n    maxPrefixLength: 0,\n    hash: 0,\n};\nexports.InnerSpec = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        writer.uint32(10).fork();\n        for (const v of message.childOrder) {\n            writer.int32(v);\n        }\n        writer.ldelim();\n        if (message.childSize !== 0) {\n            writer.uint32(16).int32(message.childSize);\n        }\n        if (message.minPrefixLength !== 0) {\n            writer.uint32(24).int32(message.minPrefixLength);\n        }\n        if (message.maxPrefixLength !== 0) {\n            writer.uint32(32).int32(message.maxPrefixLength);\n        }\n        if (message.emptyChild.length !== 0) {\n            writer.uint32(42).bytes(message.emptyChild);\n        }\n        if (message.hash !== 0) {\n            writer.uint32(48).int32(message.hash);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseInnerSpec);\n        message.childOrder = [];\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if ((tag & 7) === 2) {\n                        const end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2) {\n                            message.childOrder.push(reader.int32());\n                        }\n                    }\n                    else {\n                        message.childOrder.push(reader.int32());\n                    }\n                    break;\n                case 2:\n                    message.childSize = reader.int32();\n                    break;\n                case 3:\n                    message.minPrefixLength = reader.int32();\n                    break;\n                case 4:\n                    message.maxPrefixLength = reader.int32();\n                    break;\n                case 5:\n                    message.emptyChild = reader.bytes();\n                    break;\n                case 6:\n                    message.hash = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseInnerSpec);\n        message.childOrder = [];\n        if (object.childOrder !== undefined && object.childOrder !== null) {\n            for (const e of object.childOrder) {\n                message.childOrder.push(Number(e));\n            }\n        }\n        if (object.childSize !== undefined && object.childSize !== null) {\n            message.childSize = Number(object.childSize);\n        }\n        else {\n            message.childSize = 0;\n        }\n        if (object.minPrefixLength !== undefined &&\n            object.minPrefixLength !== null) {\n            message.minPrefixLength = Number(object.minPrefixLength);\n        }\n        else {\n            message.minPrefixLength = 0;\n        }\n        if (object.maxPrefixLength !== undefined &&\n            object.maxPrefixLength !== null) {\n            message.maxPrefixLength = Number(object.maxPrefixLength);\n        }\n        else {\n            message.maxPrefixLength = 0;\n        }\n        if (object.emptyChild !== undefined && object.emptyChild !== null) {\n            message.emptyChild = bytesFromBase64(object.emptyChild);\n        }\n        if (object.hash !== undefined && object.hash !== null) {\n            message.hash = hashOpFromJSON(object.hash);\n        }\n        else {\n            message.hash = 0;\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.childOrder) {\n            obj.childOrder = message.childOrder.map((e) => e);\n        }\n        else {\n            obj.childOrder = [];\n        }\n        message.childSize !== undefined && (obj.childSize = message.childSize);\n        message.minPrefixLength !== undefined &&\n            (obj.minPrefixLength = message.minPrefixLength);\n        message.maxPrefixLength !== undefined &&\n            (obj.maxPrefixLength = message.maxPrefixLength);\n        message.emptyChild !== undefined &&\n            (obj.emptyChild = base64FromBytes(message.emptyChild !== undefined ? message.emptyChild : new Uint8Array()));\n        message.hash !== undefined && (obj.hash = hashOpToJSON(message.hash));\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseInnerSpec);\n        message.childOrder = [];\n        if (object.childOrder !== undefined && object.childOrder !== null) {\n            for (const e of object.childOrder) {\n                message.childOrder.push(e);\n            }\n        }\n        if (object.childSize !== undefined && object.childSize !== null) {\n            message.childSize = object.childSize;\n        }\n        else {\n            message.childSize = 0;\n        }\n        if (object.minPrefixLength !== undefined &&\n            object.minPrefixLength !== null) {\n            message.minPrefixLength = object.minPrefixLength;\n        }\n        else {\n            message.minPrefixLength = 0;\n        }\n        if (object.maxPrefixLength !== undefined &&\n            object.maxPrefixLength !== null) {\n            message.maxPrefixLength = object.maxPrefixLength;\n        }\n        else {\n            message.maxPrefixLength = 0;\n        }\n        if (object.emptyChild !== undefined && object.emptyChild !== null) {\n            message.emptyChild = object.emptyChild;\n        }\n        else {\n            message.emptyChild = new Uint8Array();\n        }\n        if (object.hash !== undefined && object.hash !== null) {\n            message.hash = object.hash;\n        }\n        else {\n            message.hash = 0;\n        }\n        return message;\n    },\n};\nconst baseBatchProof = {};\nexports.BatchProof = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.entries) {\n            exports.BatchEntry.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseBatchProof);\n        message.entries = [];\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.entries.push(exports.BatchEntry.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseBatchProof);\n        message.entries = [];\n        if (object.entries !== undefined && object.entries !== null) {\n            for (const e of object.entries) {\n                message.entries.push(exports.BatchEntry.fromJSON(e));\n            }\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.entries) {\n            obj.entries = message.entries.map((e) => e ? exports.BatchEntry.toJSON(e) : undefined);\n        }\n        else {\n            obj.entries = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseBatchProof);\n        message.entries = [];\n        if (object.entries !== undefined && object.entries !== null) {\n            for (const e of object.entries) {\n                message.entries.push(exports.BatchEntry.fromPartial(e));\n            }\n        }\n        return message;\n    },\n};\nconst baseBatchEntry = {};\nexports.BatchEntry = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.exist !== undefined) {\n            exports.ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.nonexist !== undefined) {\n            exports.NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseBatchEntry);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.exist = exports.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.nonexist = exports.NonExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseBatchEntry);\n        if (object.exist !== undefined && object.exist !== null) {\n            message.exist = exports.ExistenceProof.fromJSON(object.exist);\n        }\n        else {\n            message.exist = undefined;\n        }\n        if (object.nonexist !== undefined && object.nonexist !== null) {\n            message.nonexist = exports.NonExistenceProof.fromJSON(object.nonexist);\n        }\n        else {\n            message.nonexist = undefined;\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.exist !== undefined &&\n            (obj.exist = message.exist\n                ? exports.ExistenceProof.toJSON(message.exist)\n                : undefined);\n        message.nonexist !== undefined &&\n            (obj.nonexist = message.nonexist\n                ? exports.NonExistenceProof.toJSON(message.nonexist)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseBatchEntry);\n        if (object.exist !== undefined && object.exist !== null) {\n            message.exist = exports.ExistenceProof.fromPartial(object.exist);\n        }\n        else {\n            message.exist = undefined;\n        }\n        if (object.nonexist !== undefined && object.nonexist !== null) {\n            message.nonexist = exports.NonExistenceProof.fromPartial(object.nonexist);\n        }\n        else {\n            message.nonexist = undefined;\n        }\n        return message;\n    },\n};\nconst baseCompressedBatchProof = {};\nexports.CompressedBatchProof = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.entries) {\n            exports.CompressedBatchEntry.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        for (const v of message.lookupInners) {\n            exports.InnerOp.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseCompressedBatchProof);\n        message.entries = [];\n        message.lookupInners = [];\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.entries.push(exports.CompressedBatchEntry.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.lookupInners.push(exports.InnerOp.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseCompressedBatchProof);\n        message.entries = [];\n        message.lookupInners = [];\n        if (object.entries !== undefined && object.entries !== null) {\n            for (const e of object.entries) {\n                message.entries.push(exports.CompressedBatchEntry.fromJSON(e));\n            }\n        }\n        if (object.lookupInners !== undefined && object.lookupInners !== null) {\n            for (const e of object.lookupInners) {\n                message.lookupInners.push(exports.InnerOp.fromJSON(e));\n            }\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.entries) {\n            obj.entries = message.entries.map((e) => e ? exports.CompressedBatchEntry.toJSON(e) : undefined);\n        }\n        else {\n            obj.entries = [];\n        }\n        if (message.lookupInners) {\n            obj.lookupInners = message.lookupInners.map((e) => e ? exports.InnerOp.toJSON(e) : undefined);\n        }\n        else {\n            obj.lookupInners = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseCompressedBatchProof);\n        message.entries = [];\n        message.lookupInners = [];\n        if (object.entries !== undefined && object.entries !== null) {\n            for (const e of object.entries) {\n                message.entries.push(exports.CompressedBatchEntry.fromPartial(e));\n            }\n        }\n        if (object.lookupInners !== undefined && object.lookupInners !== null) {\n            for (const e of object.lookupInners) {\n                message.lookupInners.push(exports.InnerOp.fromPartial(e));\n            }\n        }\n        return message;\n    },\n};\nconst baseCompressedBatchEntry = {};\nexports.CompressedBatchEntry = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.exist !== undefined) {\n            exports.CompressedExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.nonexist !== undefined) {\n            exports.CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseCompressedBatchEntry);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.exist = exports.CompressedExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.nonexist = exports.CompressedNonExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseCompressedBatchEntry);\n        if (object.exist !== undefined && object.exist !== null) {\n            message.exist = exports.CompressedExistenceProof.fromJSON(object.exist);\n        }\n        else {\n            message.exist = undefined;\n        }\n        if (object.nonexist !== undefined && object.nonexist !== null) {\n            message.nonexist = exports.CompressedNonExistenceProof.fromJSON(object.nonexist);\n        }\n        else {\n            message.nonexist = undefined;\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.exist !== undefined &&\n            (obj.exist = message.exist\n                ? exports.CompressedExistenceProof.toJSON(message.exist)\n                : undefined);\n        message.nonexist !== undefined &&\n            (obj.nonexist = message.nonexist\n                ? exports.CompressedNonExistenceProof.toJSON(message.nonexist)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseCompressedBatchEntry);\n        if (object.exist !== undefined && object.exist !== null) {\n            message.exist = exports.CompressedExistenceProof.fromPartial(object.exist);\n        }\n        else {\n            message.exist = undefined;\n        }\n        if (object.nonexist !== undefined && object.nonexist !== null) {\n            message.nonexist = exports.CompressedNonExistenceProof.fromPartial(object.nonexist);\n        }\n        else {\n            message.nonexist = undefined;\n        }\n        return message;\n    },\n};\nconst baseCompressedExistenceProof = { path: 0 };\nexports.CompressedExistenceProof = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.key.length !== 0) {\n            writer.uint32(10).bytes(message.key);\n        }\n        if (message.value.length !== 0) {\n            writer.uint32(18).bytes(message.value);\n        }\n        if (message.leaf !== undefined) {\n            exports.LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();\n        }\n        writer.uint32(34).fork();\n        for (const v of message.path) {\n            writer.int32(v);\n        }\n        writer.ldelim();\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseCompressedExistenceProof);\n        message.path = [];\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.value = reader.bytes();\n                    break;\n                case 3:\n                    message.leaf = exports.LeafOp.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    if ((tag & 7) === 2) {\n                        const end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2) {\n                            message.path.push(reader.int32());\n                        }\n                    }\n                    else {\n                        message.path.push(reader.int32());\n                    }\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseCompressedExistenceProof);\n        message.path = [];\n        if (object.key !== undefined && object.key !== null) {\n            message.key = bytesFromBase64(object.key);\n        }\n        if (object.value !== undefined && object.value !== null) {\n            message.value = bytesFromBase64(object.value);\n        }\n        if (object.leaf !== undefined && object.leaf !== null) {\n            message.leaf = exports.LeafOp.fromJSON(object.leaf);\n        }\n        else {\n            message.leaf = undefined;\n        }\n        if (object.path !== undefined && object.path !== null) {\n            for (const e of object.path) {\n                message.path.push(Number(e));\n            }\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined &&\n            (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));\n        message.value !== undefined &&\n            (obj.value = base64FromBytes(message.value !== undefined ? message.value : new Uint8Array()));\n        message.leaf !== undefined &&\n            (obj.leaf = message.leaf ? exports.LeafOp.toJSON(message.leaf) : undefined);\n        if (message.path) {\n            obj.path = message.path.map((e) => e);\n        }\n        else {\n            obj.path = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseCompressedExistenceProof);\n        message.path = [];\n        if (object.key !== undefined && object.key !== null) {\n            message.key = object.key;\n        }\n        else {\n            message.key = new Uint8Array();\n        }\n        if (object.value !== undefined && object.value !== null) {\n            message.value = object.value;\n        }\n        else {\n            message.value = new Uint8Array();\n        }\n        if (object.leaf !== undefined && object.leaf !== null) {\n            message.leaf = exports.LeafOp.fromPartial(object.leaf);\n        }\n        else {\n            message.leaf = undefined;\n        }\n        if (object.path !== undefined && object.path !== null) {\n            for (const e of object.path) {\n                message.path.push(e);\n            }\n        }\n        return message;\n    },\n};\nconst baseCompressedNonExistenceProof = {};\nexports.CompressedNonExistenceProof = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.key.length !== 0) {\n            writer.uint32(10).bytes(message.key);\n        }\n        if (message.left !== undefined) {\n            exports.CompressedExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.right !== undefined) {\n            exports.CompressedExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof Uint8Array ? new minimal_1.default.Reader(input) : input;\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseCompressedNonExistenceProof);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.left = exports.CompressedExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.right = exports.CompressedExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseCompressedNonExistenceProof);\n        if (object.key !== undefined && object.key !== null) {\n            message.key = bytesFromBase64(object.key);\n        }\n        if (object.left !== undefined && object.left !== null) {\n            message.left = exports.CompressedExistenceProof.fromJSON(object.left);\n        }\n        else {\n            message.left = undefined;\n        }\n        if (object.right !== undefined && object.right !== null) {\n            message.right = exports.CompressedExistenceProof.fromJSON(object.right);\n        }\n        else {\n            message.right = undefined;\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined &&\n            (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));\n        message.left !== undefined &&\n            (obj.left = message.left\n                ? exports.CompressedExistenceProof.toJSON(message.left)\n                : undefined);\n        message.right !== undefined &&\n            (obj.right = message.right\n                ? exports.CompressedExistenceProof.toJSON(message.right)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseCompressedNonExistenceProof);\n        if (object.key !== undefined && object.key !== null) {\n            message.key = object.key;\n        }\n        else {\n            message.key = new Uint8Array();\n        }\n        if (object.left !== undefined && object.left !== null) {\n            message.left = exports.CompressedExistenceProof.fromPartial(object.left);\n        }\n        else {\n            message.left = undefined;\n        }\n        if (object.right !== undefined && object.right !== null) {\n            message.right = exports.CompressedExistenceProof.fromPartial(object.right);\n        }\n        else {\n            message.right = undefined;\n        }\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== 'undefined')\n        return globalThis;\n    if (typeof self !== 'undefined')\n        return self;\n    if (typeof window !== 'undefined')\n        return window;\n    if (typeof global !== 'undefined')\n        return global;\n    throw 'Unable to locate global object';\n})();\nconst atob = globalThis.atob ||\n    ((b64) => globalThis.Buffer.from(b64, 'base64').toString('binary'));\nfunction bytesFromBase64(b64) {\n    const bin = atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nconst btoa = globalThis.btoa ||\n    ((bin) => globalThis.Buffer.from(bin, 'binary').toString('base64'));\nfunction base64FromBytes(arr) {\n    const bin = [];\n    for (let i = 0; i < arr.byteLength; ++i) {\n        bin.push(String.fromCharCode(arr[i]));\n    }\n    return btoa(bin.join(''));\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvb2ZzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvZGVjL2NvbmZpby9wcm9vZnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBRUEsaUVBQXFDO0FBRXhCLFFBQUEsZUFBZSxHQUFHLE9BQU8sQ0FBQztBQUV2QyxJQUFZLE1BVVg7QUFWRCxXQUFZLE1BQU07SUFDaEIsd0dBQXdHO0lBQ3hHLHlDQUFXLENBQUE7SUFDWCx1Q0FBVSxDQUFBO0lBQ1YsdUNBQVUsQ0FBQTtJQUNWLHVDQUFVLENBQUE7SUFDViw2Q0FBYSxDQUFBO0lBQ2IscUNBQXFDO0lBQ3JDLHlDQUFXLENBQUE7SUFDWCxvREFBaUIsQ0FBQTtBQUNuQixDQUFDLEVBVlcsTUFBTSxHQUFOLGNBQU0sS0FBTixjQUFNLFFBVWpCO0FBRUQsU0FBZ0IsY0FBYyxDQUFDLE1BQVc7SUFDeEMsUUFBUSxNQUFNLEVBQUU7UUFDZCxLQUFLLENBQUMsQ0FBQztRQUNQLEtBQUssU0FBUztZQUNaLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQztRQUN4QixLQUFLLENBQUMsQ0FBQztRQUNQLEtBQUssUUFBUTtZQUNYLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUN2QixLQUFLLENBQUMsQ0FBQztRQUNQLEtBQUssUUFBUTtZQUNYLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUN2QixLQUFLLENBQUMsQ0FBQztRQUNQLEtBQUssUUFBUTtZQUNYLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUN2QixLQUFLLENBQUMsQ0FBQztRQUNQLEtBQUssV0FBVztZQUNkLE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FBQztRQUMxQixLQUFLLENBQUMsQ0FBQztRQUNQLEtBQUssU0FBUztZQUNaLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQztRQUN4QixLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ1IsS0FBSyxjQUFjLENBQUM7UUFDcEI7WUFDRSxPQUFPLE1BQU0sQ0FB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LEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxFQUFFO1FBQ25DLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQzVCO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBRUQsTUFBTSxJQUFJLEdBQ1IsVUFBVSxDQUFDLElBQUk7SUFDZixDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7QUFDdEUsU0FBUyxlQUFlLENBQUMsR0FBZTtJQUN0QyxNQUFNLEdBQUcsR0FBYSxFQUFFLENBQUM7SUFDekIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDLEVBQUU7UUFDdkMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDdkM7SUFDRCxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDNUIsQ0FBQyJ9"]},"metadata":{},"sourceType":"script"}