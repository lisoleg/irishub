{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.typed-array.at.js\");\n\nrequire(\"core-js/modules/es.typed-array.set.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeBech32Pubkey = exports.encodeAminoPubkey = exports.decodeBech32Pubkey = exports.decodeAminoPubkey = exports.encodeSecp256k1Pubkey = void 0;\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst math_1 = require(\"@cosmjs/math\");\n\nconst utils_1 = require(\"@cosmjs/utils\");\n\nconst pubkeys_1 = require(\"./pubkeys\");\n\nfunction encodeSecp256k1Pubkey(pubkey) {\n  if (pubkey.length !== 33 || pubkey[0] !== 0x02 && pubkey[0] !== 0x03) {\n    throw new Error(\"Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03\");\n  }\n\n  return {\n    type: pubkeys_1.pubkeyType.secp256k1,\n    value: encoding_1.toBase64(pubkey)\n  };\n}\n\nexports.encodeSecp256k1Pubkey = encodeSecp256k1Pubkey; // As discussed in https://github.com/binance-chain/javascript-sdk/issues/163\n// Prefixes listed here: https://github.com/tendermint/tendermint/blob/d419fffe18531317c28c29a292ad7d253f6cafdf/docs/spec/blockchain/encoding.md#public-key-cryptography\n// Last bytes is varint-encoded length prefix\n\nconst pubkeyAminoPrefixSecp256k1 = encoding_1.fromHex(\"eb5ae987\" + \"21\"\n/* fixed length */\n);\nconst pubkeyAminoPrefixEd25519 = encoding_1.fromHex(\"1624de64\" + \"20\"\n/* fixed length */\n);\nconst pubkeyAminoPrefixSr25519 = encoding_1.fromHex(\"0dfb1005\" + \"20\"\n/* fixed length */\n);\n/** See https://github.com/tendermint/tendermint/commit/38b401657e4ad7a7eeb3c30a3cbf512037df3740 */\n\nconst pubkeyAminoPrefixMultisigThreshold = encoding_1.fromHex(\"22c1f7e2\"\n/* variable length not included */\n);\n/**\n * Decodes a pubkey in the Amino binary format to a type/value object.\n */\n\nfunction decodeAminoPubkey(data) {\n  if (utils_1.arrayContentStartsWith(data, pubkeyAminoPrefixSecp256k1)) {\n    const rest = data.slice(pubkeyAminoPrefixSecp256k1.length);\n\n    if (rest.length !== 33) {\n      throw new Error(\"Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).\");\n    }\n\n    return {\n      type: pubkeys_1.pubkeyType.secp256k1,\n      value: encoding_1.toBase64(rest)\n    };\n  } else if (utils_1.arrayContentStartsWith(data, pubkeyAminoPrefixEd25519)) {\n    const rest = data.slice(pubkeyAminoPrefixEd25519.length);\n\n    if (rest.length !== 32) {\n      throw new Error(\"Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).\");\n    }\n\n    return {\n      type: pubkeys_1.pubkeyType.ed25519,\n      value: encoding_1.toBase64(rest)\n    };\n  } else if (utils_1.arrayContentStartsWith(data, pubkeyAminoPrefixSr25519)) {\n    const rest = data.slice(pubkeyAminoPrefixSr25519.length);\n\n    if (rest.length !== 32) {\n      throw new Error(\"Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).\");\n    }\n\n    return {\n      type: pubkeys_1.pubkeyType.sr25519,\n      value: encoding_1.toBase64(rest)\n    };\n  } else if (utils_1.arrayContentStartsWith(data, pubkeyAminoPrefixMultisigThreshold)) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return decodeMultisigPubkey(data);\n  } else {\n    throw new Error(\"Unsupported public key type. Amino data starts with: \" + encoding_1.toHex(data.slice(0, 5)));\n  }\n}\n\nexports.decodeAminoPubkey = decodeAminoPubkey;\n/**\n * Decodes a bech32 pubkey to Amino binary, which is then decoded to a type/value object.\n * The bech32 prefix is ignored and discareded.\n *\n * @param bechEncoded the bech32 encoded pubkey\n */\n\nfunction decodeBech32Pubkey(bechEncoded) {\n  const {\n    data\n  } = encoding_1.Bech32.decode(bechEncoded);\n  return decodeAminoPubkey(data);\n}\n\nexports.decodeBech32Pubkey = decodeBech32Pubkey;\n/**\n * Uvarint decoder for Amino.\n * @see https://github.com/tendermint/go-amino/blob/8e779b71f40d175/decoder.go#L64-76\n * @returns varint as number, and bytes count occupied by varaint\n */\n\nfunction decodeUvarint(reader) {\n  if (reader.length < 1) {\n    throw new Error(\"Can't decode varint. EOF\");\n  }\n\n  if (reader[0] > 127) {\n    throw new Error(\"Decoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.Varint implementation from the Go standard library and write some tests.\");\n  }\n\n  return [reader[0], 1];\n}\n/**\n * Decodes a multisig pubkey to type object.\n * Pubkey structure [ prefix + const + threshold + loop:(const + pubkeyLength + pubkey            ) ]\n *                  [   4b   + 1b    +  varint   + loop:(1b    +    varint    + pubkeyLength bytes) ]\n * @param data encoded pubkey\n */\n\n\nfunction decodeMultisigPubkey(data) {\n  const reader = Array.from(data); // remove multisig amino prefix;\n\n  const prefixFromReader = reader.splice(0, pubkeyAminoPrefixMultisigThreshold.length);\n\n  if (!utils_1.arrayContentStartsWith(prefixFromReader, pubkeyAminoPrefixMultisigThreshold)) {\n    throw new Error(\"Invalid multisig prefix.\");\n  } // remove 0x08 threshold prefix;\n\n\n  if (reader.shift() != 0x08) {\n    throw new Error(\"Invalid multisig data. Expecting 0x08 prefix before threshold.\");\n  } // read threshold\n\n\n  const [threshold, thresholdBytesLength] = decodeUvarint(reader);\n  reader.splice(0, thresholdBytesLength); // read participants pubkeys\n\n  const pubkeys = [];\n\n  while (reader.length > 0) {\n    // remove 0x12 threshold prefix;\n    if (reader.shift() != 0x12) {\n      throw new Error(\"Invalid multisig data. Expecting 0x12 prefix before participant pubkey length.\");\n    } // read pubkey length\n\n\n    const [pubkeyLength, pubkeyLengthBytesSize] = decodeUvarint(reader);\n    reader.splice(0, pubkeyLengthBytesSize); // verify that we can read pubkey\n\n    if (reader.length < pubkeyLength) {\n      throw new Error(\"Invalid multisig data length.\");\n    } // read and decode participant pubkey\n\n\n    const encodedPubkey = reader.splice(0, pubkeyLength);\n    const pubkey = decodeAminoPubkey(Uint8Array.from(encodedPubkey));\n    pubkeys.push(pubkey);\n  }\n\n  return {\n    type: pubkeys_1.pubkeyType.multisigThreshold,\n    value: {\n      threshold: threshold.toString(),\n      pubkeys: pubkeys\n    }\n  };\n}\n/**\n * Uvarint encoder for Amino. This is the same encoding as `binary.PutUvarint` from the Go\n * standard library.\n *\n * @see https://github.com/tendermint/go-amino/blob/8e779b71f40d175/encoder.go#L77-L85\n */\n\n\nfunction encodeUvarint(value) {\n  const checked = math_1.Uint53.fromString(value.toString()).toNumber();\n\n  if (checked > 127) {\n    throw new Error(\"Encoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.PutUvarint implementation from the Go standard library and write some tests.\");\n  }\n\n  return [checked];\n}\n/**\n * Encodes a public key to binary Amino.\n */\n\n\nfunction encodeAminoPubkey(pubkey) {\n  if (pubkeys_1.isMultisigThresholdPubkey(pubkey)) {\n    const out = Array.from(pubkeyAminoPrefixMultisigThreshold);\n    out.push(0x08); // TODO: What is this?\n\n    out.push(...encodeUvarint(pubkey.value.threshold));\n\n    for (const pubkeyData of pubkey.value.pubkeys.map(p => encodeAminoPubkey(p))) {\n      out.push(0x12); // TODO: What is this?\n\n      out.push(...encodeUvarint(pubkeyData.length));\n      out.push(...pubkeyData);\n    }\n\n    return new Uint8Array(out);\n  } else if (pubkeys_1.isEd25519Pubkey(pubkey)) {\n    return new Uint8Array([...pubkeyAminoPrefixEd25519, ...encoding_1.fromBase64(pubkey.value)]);\n  } else if (pubkeys_1.isSecp256k1Pubkey(pubkey)) {\n    return new Uint8Array([...pubkeyAminoPrefixSecp256k1, ...encoding_1.fromBase64(pubkey.value)]);\n  } else {\n    throw new Error(\"Unsupported pubkey type\");\n  }\n}\n\nexports.encodeAminoPubkey = encodeAminoPubkey;\n/**\n * Encodes a public key to binary Amino and then to bech32.\n *\n * @param pubkey the public key to encode\n * @param prefix the bech32 prefix (human readable part)\n */\n\nfunction encodeBech32Pubkey(pubkey, prefix) {\n  return encoding_1.Bech32.encode(prefix, encodeAminoPubkey(pubkey));\n}\n\nexports.encodeBech32Pubkey = encodeBech32Pubkey;","map":{"version":3,"sources":["../src/encoding.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encodeBech32Pubkey = exports.encodeAminoPubkey = exports.decodeBech32Pubkey = exports.decodeAminoPubkey = exports.encodeSecp256k1Pubkey = void 0;\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst math_1 = require(\"@cosmjs/math\");\nconst utils_1 = require(\"@cosmjs/utils\");\nconst pubkeys_1 = require(\"./pubkeys\");\nfunction encodeSecp256k1Pubkey(pubkey) {\n    if (pubkey.length !== 33 || (pubkey[0] !== 0x02 && pubkey[0] !== 0x03)) {\n        throw new Error(\"Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03\");\n    }\n    return {\n        type: pubkeys_1.pubkeyType.secp256k1,\n        value: encoding_1.toBase64(pubkey),\n    };\n}\nexports.encodeSecp256k1Pubkey = encodeSecp256k1Pubkey;\n// As discussed in https://github.com/binance-chain/javascript-sdk/issues/163\n// Prefixes listed here: https://github.com/tendermint/tendermint/blob/d419fffe18531317c28c29a292ad7d253f6cafdf/docs/spec/blockchain/encoding.md#public-key-cryptography\n// Last bytes is varint-encoded length prefix\nconst pubkeyAminoPrefixSecp256k1 = encoding_1.fromHex(\"eb5ae987\" + \"21\" /* fixed length */);\nconst pubkeyAminoPrefixEd25519 = encoding_1.fromHex(\"1624de64\" + \"20\" /* fixed length */);\nconst pubkeyAminoPrefixSr25519 = encoding_1.fromHex(\"0dfb1005\" + \"20\" /* fixed length */);\n/** See https://github.com/tendermint/tendermint/commit/38b401657e4ad7a7eeb3c30a3cbf512037df3740 */\nconst pubkeyAminoPrefixMultisigThreshold = encoding_1.fromHex(\"22c1f7e2\" /* variable length not included */);\n/**\n * Decodes a pubkey in the Amino binary format to a type/value object.\n */\nfunction decodeAminoPubkey(data) {\n    if (utils_1.arrayContentStartsWith(data, pubkeyAminoPrefixSecp256k1)) {\n        const rest = data.slice(pubkeyAminoPrefixSecp256k1.length);\n        if (rest.length !== 33) {\n            throw new Error(\"Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).\");\n        }\n        return {\n            type: pubkeys_1.pubkeyType.secp256k1,\n            value: encoding_1.toBase64(rest),\n        };\n    }\n    else if (utils_1.arrayContentStartsWith(data, pubkeyAminoPrefixEd25519)) {\n        const rest = data.slice(pubkeyAminoPrefixEd25519.length);\n        if (rest.length !== 32) {\n            throw new Error(\"Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).\");\n        }\n        return {\n            type: pubkeys_1.pubkeyType.ed25519,\n            value: encoding_1.toBase64(rest),\n        };\n    }\n    else if (utils_1.arrayContentStartsWith(data, pubkeyAminoPrefixSr25519)) {\n        const rest = data.slice(pubkeyAminoPrefixSr25519.length);\n        if (rest.length !== 32) {\n            throw new Error(\"Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).\");\n        }\n        return {\n            type: pubkeys_1.pubkeyType.sr25519,\n            value: encoding_1.toBase64(rest),\n        };\n    }\n    else if (utils_1.arrayContentStartsWith(data, pubkeyAminoPrefixMultisigThreshold)) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return decodeMultisigPubkey(data);\n    }\n    else {\n        throw new Error(\"Unsupported public key type. Amino data starts with: \" + encoding_1.toHex(data.slice(0, 5)));\n    }\n}\nexports.decodeAminoPubkey = decodeAminoPubkey;\n/**\n * Decodes a bech32 pubkey to Amino binary, which is then decoded to a type/value object.\n * The bech32 prefix is ignored and discareded.\n *\n * @param bechEncoded the bech32 encoded pubkey\n */\nfunction decodeBech32Pubkey(bechEncoded) {\n    const { data } = encoding_1.Bech32.decode(bechEncoded);\n    return decodeAminoPubkey(data);\n}\nexports.decodeBech32Pubkey = decodeBech32Pubkey;\n/**\n * Uvarint decoder for Amino.\n * @see https://github.com/tendermint/go-amino/blob/8e779b71f40d175/decoder.go#L64-76\n * @returns varint as number, and bytes count occupied by varaint\n */\nfunction decodeUvarint(reader) {\n    if (reader.length < 1) {\n        throw new Error(\"Can't decode varint. EOF\");\n    }\n    if (reader[0] > 127) {\n        throw new Error(\"Decoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.Varint implementation from the Go standard library and write some tests.\");\n    }\n    return [reader[0], 1];\n}\n/**\n * Decodes a multisig pubkey to type object.\n * Pubkey structure [ prefix + const + threshold + loop:(const + pubkeyLength + pubkey            ) ]\n *                  [   4b   + 1b    +  varint   + loop:(1b    +    varint    + pubkeyLength bytes) ]\n * @param data encoded pubkey\n */\nfunction decodeMultisigPubkey(data) {\n    const reader = Array.from(data);\n    // remove multisig amino prefix;\n    const prefixFromReader = reader.splice(0, pubkeyAminoPrefixMultisigThreshold.length);\n    if (!utils_1.arrayContentStartsWith(prefixFromReader, pubkeyAminoPrefixMultisigThreshold)) {\n        throw new Error(\"Invalid multisig prefix.\");\n    }\n    // remove 0x08 threshold prefix;\n    if (reader.shift() != 0x08) {\n        throw new Error(\"Invalid multisig data. Expecting 0x08 prefix before threshold.\");\n    }\n    // read threshold\n    const [threshold, thresholdBytesLength] = decodeUvarint(reader);\n    reader.splice(0, thresholdBytesLength);\n    // read participants pubkeys\n    const pubkeys = [];\n    while (reader.length > 0) {\n        // remove 0x12 threshold prefix;\n        if (reader.shift() != 0x12) {\n            throw new Error(\"Invalid multisig data. Expecting 0x12 prefix before participant pubkey length.\");\n        }\n        // read pubkey length\n        const [pubkeyLength, pubkeyLengthBytesSize] = decodeUvarint(reader);\n        reader.splice(0, pubkeyLengthBytesSize);\n        // verify that we can read pubkey\n        if (reader.length < pubkeyLength) {\n            throw new Error(\"Invalid multisig data length.\");\n        }\n        // read and decode participant pubkey\n        const encodedPubkey = reader.splice(0, pubkeyLength);\n        const pubkey = decodeAminoPubkey(Uint8Array.from(encodedPubkey));\n        pubkeys.push(pubkey);\n    }\n    return {\n        type: pubkeys_1.pubkeyType.multisigThreshold,\n        value: {\n            threshold: threshold.toString(),\n            pubkeys: pubkeys,\n        },\n    };\n}\n/**\n * Uvarint encoder for Amino. This is the same encoding as `binary.PutUvarint` from the Go\n * standard library.\n *\n * @see https://github.com/tendermint/go-amino/blob/8e779b71f40d175/encoder.go#L77-L85\n */\nfunction encodeUvarint(value) {\n    const checked = math_1.Uint53.fromString(value.toString()).toNumber();\n    if (checked > 127) {\n        throw new Error(\"Encoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.PutUvarint implementation from the Go standard library and write some tests.\");\n    }\n    return [checked];\n}\n/**\n * Encodes a public key to binary Amino.\n */\nfunction encodeAminoPubkey(pubkey) {\n    if (pubkeys_1.isMultisigThresholdPubkey(pubkey)) {\n        const out = Array.from(pubkeyAminoPrefixMultisigThreshold);\n        out.push(0x08); // TODO: What is this?\n        out.push(...encodeUvarint(pubkey.value.threshold));\n        for (const pubkeyData of pubkey.value.pubkeys.map((p) => encodeAminoPubkey(p))) {\n            out.push(0x12); // TODO: What is this?\n            out.push(...encodeUvarint(pubkeyData.length));\n            out.push(...pubkeyData);\n        }\n        return new Uint8Array(out);\n    }\n    else if (pubkeys_1.isEd25519Pubkey(pubkey)) {\n        return new Uint8Array([...pubkeyAminoPrefixEd25519, ...encoding_1.fromBase64(pubkey.value)]);\n    }\n    else if (pubkeys_1.isSecp256k1Pubkey(pubkey)) {\n        return new Uint8Array([...pubkeyAminoPrefixSecp256k1, ...encoding_1.fromBase64(pubkey.value)]);\n    }\n    else {\n        throw new Error(\"Unsupported pubkey type\");\n    }\n}\nexports.encodeAminoPubkey = encodeAminoPubkey;\n/**\n * Encodes a public key to binary Amino and then to bech32.\n *\n * @param pubkey the public key to encode\n * @param prefix the bech32 prefix (human readable part)\n */\nfunction encodeBech32Pubkey(pubkey, prefix) {\n    return encoding_1.Bech32.encode(prefix, encodeAminoPubkey(pubkey));\n}\nexports.encodeBech32Pubkey = encodeBech32Pubkey;\n//# sourceMappingURL=encoding.js.map"]},"metadata":{},"sourceType":"script"}