{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _stargate = require(\"@cosmjs/stargate\");\n\nvar _crypto = require(\"@cosmjs/crypto\");\n\nvar _utils = require(\"@cosmjs/utils\");\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n} // This is a wrapper around SigningStargateClient that waits up to an additional 1 minute for a Tx to be committed regardless of rpc endpoint timeout response\n\n\nvar StarportSigningClient = /*#__PURE__*/function (_SigningStargateClien) {\n  _inherits(StarportSigningClient, _SigningStargateClien);\n\n  var _super = _createSuper(StarportSigningClient);\n\n  function StarportSigningClient() {\n    _classCallCheck(this, StarportSigningClient);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(StarportSigningClient, [{\n    key: \"signAndBroadcast\",\n    value: function () {\n      var _signAndBroadcast = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(signerAddress, messages, fee) {\n        var memo,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                memo = _args.length > 3 && _args[3] !== undefined ? _args[3] : '';\n                return _context.abrupt(\"return\", _get(_getPrototypeOf(StarportSigningClient.prototype), \"signAndBroadcast\", this).call(this, signerAddress, messages, fee, memo));\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function signAndBroadcast(_x, _x2, _x3) {\n        return _signAndBroadcast.apply(this, arguments);\n      }\n\n      return signAndBroadcast;\n    }()\n  }, {\n    key: \"broadcastTx\",\n    value: function () {\n      var _broadcastTx = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(tx) {\n        var result, error, txHash, i, res;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return _get(_getPrototypeOf(StarportSigningClient.prototype), \"broadcastTx\", this).call(this, tx);\n\n              case 3:\n                result = _context2.sent;\n                return _context2.abrupt(\"return\", result);\n\n              case 7:\n                _context2.prev = 7;\n                _context2.t0 = _context2[\"catch\"](0);\n                _context2.prev = 9;\n                error = JSON.parse(_context2.t0.message);\n\n                if (!(error.code == -32603 && error.data == 'timed out waiting for tx to be included in a block')) {\n                  _context2.next = 33;\n                  break;\n                }\n\n                txHash = (0, _crypto.sha256)(tx);\n                i = 0;\n\n              case 14:\n                if (!(i < 20)) {\n                  _context2.next = 30;\n                  break;\n                }\n\n                _context2.prev = 15;\n                _context2.next = 18;\n                return this.tmClient.tx({\n                  hash: txHash,\n                  prove: true\n                });\n\n              case 18:\n                res = _context2.sent;\n                return _context2.abrupt(\"return\", {\n                  height: res.height,\n                  code: res.result.code,\n                  rawLog: res.result.log\n                });\n\n              case 22:\n                _context2.prev = 22;\n                _context2.t1 = _context2[\"catch\"](15);\n                console.log('Waiting for tx to be included in a block');\n\n              case 25:\n                i++;\n                _context2.next = 28;\n                return (0, _utils.sleep)(3000);\n\n              case 28:\n                _context2.next = 14;\n                break;\n\n              case 30:\n                throw _context2.t0;\n\n              case 33:\n                throw _context2.t0;\n\n              case 34:\n                _context2.next = 39;\n                break;\n\n              case 36:\n                _context2.prev = 36;\n                _context2.t2 = _context2[\"catch\"](9);\n                throw _context2.t0;\n\n              case 39:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 7], [9, 36], [15, 22]]);\n      }));\n\n      function broadcastTx(_x4) {\n        return _broadcastTx.apply(this, arguments);\n      }\n\n      return broadcastTx;\n    }()\n  }]);\n\n  return StarportSigningClient;\n}(_stargate.SigningStargateClient);\n\nexports[\"default\"] = StarportSigningClient;","map":{"version":3,"sources":["../../../../../src/modules/common/relayers/libs/starportSigningClient.js"],"names":["StarportSigningClient","SigningStargateClient","memo","result","error","JSON","txHash","i","res","hash","prove","height","code","rawLog","log","console"],"mappings":"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","sourcesContent":["import { SigningStargateClient } from '@cosmjs/stargate'\nimport { sha256 } from '@cosmjs/crypto'\nimport { sleep } from '@cosmjs/utils'\n\n// This is a wrapper around SigningStargateClient that waits up to an additional 1 minute for a Tx to be committed regardless of rpc endpoint timeout response\n\nexport default class StarportSigningClient extends SigningStargateClient {\n\tasync signAndBroadcast(signerAddress, messages, fee, memo = '') {\n\t\treturn super.signAndBroadcast(signerAddress, messages, fee, memo)\n\t}\n\tasync broadcastTx(tx) {\n\t\tlet result\n\t\ttry {\n\t\t\tresult = await super.broadcastTx(tx)\n\t\t\treturn result\n\t\t} catch (e) {\n\t\t\ttry {\n\t\t\t\tlet error = JSON.parse(e.message)\n\t\t\t\tif (error.code == -32603 && error.data == 'timed out waiting for tx to be included in a block') {\n\t\t\t\t\tlet txHash = sha256(tx)\n\t\t\t\t\tlet i = 0\n\t\t\t\t\twhile (i < 20) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlet res = await this.tmClient.tx({\n\t\t\t\t\t\t\t\thash: txHash,\n\t\t\t\t\t\t\t\tprove: true,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\theight: res.height,\n\t\t\t\t\t\t\t\tcode: res.result.code,\n\t\t\t\t\t\t\t\trawLog: res.result.log,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tconsole.log('Waiting for tx to be included in a block')\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti++\n\t\t\t\t\t\tawait sleep(3000)\n\t\t\t\t\t}\n\t\t\t\t\tthrow e\n\t\t\t\t} else {\n\t\t\t\t\tthrow e\n\t\t\t\t}\n\t\t\t} catch (notjson) {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"script"}