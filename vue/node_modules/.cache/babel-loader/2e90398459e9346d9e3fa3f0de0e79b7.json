{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n\n/*!\n  * message-compiler v9.2.0-beta.26\n  * (c) 2021 kazuya kawaguchi\n  * Released under the MIT License.\n  */\nimport { format, assign, isString } from '@intlify/shared';\nconst CompileErrorCodes = {\n  // tokenizer error codes\n  EXPECTED_TOKEN: 1,\n  INVALID_TOKEN_IN_PLACEHOLDER: 2,\n  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,\n  UNKNOWN_ESCAPE_SEQUENCE: 4,\n  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,\n  UNBALANCED_CLOSING_BRACE: 6,\n  UNTERMINATED_CLOSING_BRACE: 7,\n  EMPTY_PLACEHOLDER: 8,\n  NOT_ALLOW_NEST_PLACEHOLDER: 9,\n  INVALID_LINKED_FORMAT: 10,\n  // parser error codes\n  MUST_HAVE_MESSAGES_IN_PLURAL: 11,\n  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,\n  UNEXPECTED_EMPTY_LINKED_KEY: 13,\n  UNEXPECTED_LEXICAL_ANALYSIS: 14,\n  // Special value for higher-order compilers to pick up the last code\n  // to avoid collision of error codes. This should always be kept as the last\n  // item.\n  __EXTEND_POINT__: 15\n};\n/** @internal */\n\nconst errorMessages = {\n  // tokenizer error messages\n  [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,\n  [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,\n  [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,\n  [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\\\{0}`,\n  [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,\n  [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,\n  [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,\n  [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,\n  [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,\n  [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,\n  // parser error messages\n  [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,\n  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,\n  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,\n  [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`\n};\n\nfunction createCompileError(code, loc, options = {}) {\n  const {\n    domain,\n    messages,\n    args\n  } = options;\n  const msg = process.env.NODE_ENV !== 'production' ? format((messages || errorMessages)[code] || '', ...(args || [])) : code;\n  const error = new SyntaxError(String(msg));\n  error.code = code;\n\n  if (loc) {\n    error.location = loc;\n  }\n\n  error.domain = domain;\n  return error;\n}\n/** @internal */\n\n\nfunction defaultOnError(error) {\n  throw error;\n}\n\nconst LocationStub = {\n  start: {\n    line: 1,\n    column: 1,\n    offset: 0\n  },\n  end: {\n    line: 1,\n    column: 1,\n    offset: 0\n  }\n};\n\nfunction createPosition(line, column, offset) {\n  return {\n    line,\n    column,\n    offset\n  };\n}\n\nfunction createLocation(start, end, source) {\n  const loc = {\n    start,\n    end\n  };\n\n  if (source != null) {\n    loc.source = source;\n  }\n\n  return loc;\n}\n\nconst CHAR_SP = ' ';\nconst CHAR_CR = '\\r';\nconst CHAR_LF = '\\n';\nconst CHAR_LS = String.fromCharCode(0x2028);\nconst CHAR_PS = String.fromCharCode(0x2029);\n\nfunction createScanner(str) {\n  const _buf = str;\n  let _index = 0;\n  let _line = 1;\n  let _column = 1;\n  let _peekOffset = 0;\n\n  const isCRLF = index => _buf[index] === CHAR_CR && _buf[index + 1] === CHAR_LF;\n\n  const isLF = index => _buf[index] === CHAR_LF;\n\n  const isPS = index => _buf[index] === CHAR_PS;\n\n  const isLS = index => _buf[index] === CHAR_LS;\n\n  const isLineEnd = index => isCRLF(index) || isLF(index) || isPS(index) || isLS(index);\n\n  const index = () => _index;\n\n  const line = () => _line;\n\n  const column = () => _column;\n\n  const peekOffset = () => _peekOffset;\n\n  const charAt = offset => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];\n\n  const currentChar = () => charAt(_index);\n\n  const currentPeek = () => charAt(_index + _peekOffset);\n\n  function next() {\n    _peekOffset = 0;\n\n    if (isLineEnd(_index)) {\n      _line++;\n      _column = 0;\n    }\n\n    if (isCRLF(_index)) {\n      _index++;\n    }\n\n    _index++;\n    _column++;\n    return _buf[_index];\n  }\n\n  function peek() {\n    if (isCRLF(_index + _peekOffset)) {\n      _peekOffset++;\n    }\n\n    _peekOffset++;\n    return _buf[_index + _peekOffset];\n  }\n\n  function reset() {\n    _index = 0;\n    _line = 1;\n    _column = 1;\n    _peekOffset = 0;\n  }\n\n  function resetPeek(offset = 0) {\n    _peekOffset = offset;\n  }\n\n  function skipToPeek() {\n    const target = _index + _peekOffset; // eslint-disable-next-line no-unmodified-loop-condition\n\n    while (target !== _index) {\n      next();\n    }\n\n    _peekOffset = 0;\n  }\n\n  return {\n    index,\n    line,\n    column,\n    peekOffset,\n    charAt,\n    currentChar,\n    currentPeek,\n    next,\n    peek,\n    reset,\n    resetPeek,\n    skipToPeek\n  };\n}\n\nconst EOF = undefined;\nconst LITERAL_DELIMITER = \"'\";\nconst ERROR_DOMAIN$1 = 'tokenizer';\n\nfunction createTokenizer(source, options = {}) {\n  const location = options.location !== false;\n\n  const _scnr = createScanner(source);\n\n  const currentOffset = () => _scnr.index();\n\n  const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());\n\n  const _initLoc = currentPosition();\n\n  const _initOffset = currentOffset();\n\n  const _context = {\n    currentType: 14\n    /* EOF */\n    ,\n    offset: _initOffset,\n    startLoc: _initLoc,\n    endLoc: _initLoc,\n    lastType: 14\n    /* EOF */\n    ,\n    lastOffset: _initOffset,\n    lastStartLoc: _initLoc,\n    lastEndLoc: _initLoc,\n    braceNest: 0,\n    inLinked: false,\n    text: ''\n  };\n\n  const context = () => _context;\n\n  const {\n    onError\n  } = options;\n\n  function emitError(code, pos, offset, ...args) {\n    const ctx = context();\n    pos.column += offset;\n    pos.offset += offset;\n\n    if (onError) {\n      const loc = createLocation(ctx.startLoc, pos);\n      const err = createCompileError(code, loc, {\n        domain: ERROR_DOMAIN$1,\n        args\n      });\n      onError(err);\n    }\n  }\n\n  function getToken(context, type, value) {\n    context.endLoc = currentPosition();\n    context.currentType = type;\n    const token = {\n      type\n    };\n\n    if (location) {\n      token.loc = createLocation(context.startLoc, context.endLoc);\n    }\n\n    if (value != null) {\n      token.value = value;\n    }\n\n    return token;\n  }\n\n  const getEndToken = context => getToken(context, 14\n  /* EOF */\n  );\n\n  function eat(scnr, ch) {\n    if (scnr.currentChar() === ch) {\n      scnr.next();\n      return ch;\n    } else {\n      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);\n      return '';\n    }\n  }\n\n  function peekSpaces(scnr) {\n    let buf = '';\n\n    while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {\n      buf += scnr.currentPeek();\n      scnr.peek();\n    }\n\n    return buf;\n  }\n\n  function skipSpaces(scnr) {\n    const buf = peekSpaces(scnr);\n    scnr.skipToPeek();\n    return buf;\n  }\n\n  function isIdentifierStart(ch) {\n    if (ch === EOF) {\n      return false;\n    }\n\n    const cc = ch.charCodeAt(0);\n    return cc >= 97 && cc <= 122 || // a-z\n    cc >= 65 && cc <= 90 || // A-Z\n    cc === 95 // _\n    ;\n  }\n\n  function isNumberStart(ch) {\n    if (ch === EOF) {\n      return false;\n    }\n\n    const cc = ch.charCodeAt(0);\n    return cc >= 48 && cc <= 57; // 0-9\n  }\n\n  function isNamedIdentifierStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n\n    if (currentType !== 2\n    /* BraceLeft */\n    ) {\n      return false;\n    }\n\n    peekSpaces(scnr);\n    const ret = isIdentifierStart(scnr.currentPeek());\n    scnr.resetPeek();\n    return ret;\n  }\n\n  function isListIdentifierStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n\n    if (currentType !== 2\n    /* BraceLeft */\n    ) {\n      return false;\n    }\n\n    peekSpaces(scnr);\n    const ch = scnr.currentPeek() === '-' ? scnr.peek() : scnr.currentPeek();\n    const ret = isNumberStart(ch);\n    scnr.resetPeek();\n    return ret;\n  }\n\n  function isLiteralStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n\n    if (currentType !== 2\n    /* BraceLeft */\n    ) {\n      return false;\n    }\n\n    peekSpaces(scnr);\n    const ret = scnr.currentPeek() === LITERAL_DELIMITER;\n    scnr.resetPeek();\n    return ret;\n  }\n\n  function isLinkedDotStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n\n    if (currentType !== 8\n    /* LinkedAlias */\n    ) {\n      return false;\n    }\n\n    peekSpaces(scnr);\n    const ret = scnr.currentPeek() === \".\"\n    /* LinkedDot */\n    ;\n    scnr.resetPeek();\n    return ret;\n  }\n\n  function isLinkedModifierStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n\n    if (currentType !== 9\n    /* LinkedDot */\n    ) {\n      return false;\n    }\n\n    peekSpaces(scnr);\n    const ret = isIdentifierStart(scnr.currentPeek());\n    scnr.resetPeek();\n    return ret;\n  }\n\n  function isLinkedDelimiterStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n\n    if (!(currentType === 8\n    /* LinkedAlias */\n    || currentType === 12\n    /* LinkedModifier */\n    )) {\n      return false;\n    }\n\n    peekSpaces(scnr);\n    const ret = scnr.currentPeek() === \":\"\n    /* LinkedDelimiter */\n    ;\n    scnr.resetPeek();\n    return ret;\n  }\n\n  function isLinkedReferStart(scnr, context) {\n    const {\n      currentType\n    } = context;\n\n    if (currentType !== 10\n    /* LinkedDelimiter */\n    ) {\n      return false;\n    }\n\n    const fn = () => {\n      const ch = scnr.currentPeek();\n\n      if (ch === \"{\"\n      /* BraceLeft */\n      ) {\n        return isIdentifierStart(scnr.peek());\n      } else if (ch === \"@\"\n      /* LinkedAlias */\n      || ch === \"%\"\n      /* Modulo */\n      || ch === \"|\"\n      /* Pipe */\n      || ch === \":\"\n      /* LinkedDelimiter */\n      || ch === \".\"\n      /* LinkedDot */\n      || ch === CHAR_SP || !ch) {\n        return false;\n      } else if (ch === CHAR_LF) {\n        scnr.peek();\n        return fn();\n      } else {\n        // other characters\n        return isIdentifierStart(ch);\n      }\n    };\n\n    const ret = fn();\n    scnr.resetPeek();\n    return ret;\n  }\n\n  function isPluralStart(scnr) {\n    peekSpaces(scnr);\n    const ret = scnr.currentPeek() === \"|\"\n    /* Pipe */\n    ;\n    scnr.resetPeek();\n    return ret;\n  }\n\n  function isTextStart(scnr, reset = true) {\n    const fn = (hasSpace = false, prev = '', detectModulo = false) => {\n      const ch = scnr.currentPeek();\n\n      if (ch === \"{\"\n      /* BraceLeft */\n      ) {\n        return prev === \"%\"\n        /* Modulo */\n        ? false : hasSpace;\n      } else if (ch === \"@\"\n      /* LinkedAlias */\n      || !ch) {\n        return prev === \"%\"\n        /* Modulo */\n        ? true : hasSpace;\n      } else if (ch === \"%\"\n      /* Modulo */\n      ) {\n        scnr.peek();\n        return fn(hasSpace, \"%\"\n        /* Modulo */\n        , true);\n      } else if (ch === \"|\"\n      /* Pipe */\n      ) {\n        return prev === \"%\"\n        /* Modulo */\n        || detectModulo ? true : !(prev === CHAR_SP || prev === CHAR_LF);\n      } else if (ch === CHAR_SP) {\n        scnr.peek();\n        return fn(true, CHAR_SP, detectModulo);\n      } else if (ch === CHAR_LF) {\n        scnr.peek();\n        return fn(true, CHAR_LF, detectModulo);\n      } else {\n        return true;\n      }\n    };\n\n    const ret = fn();\n    reset && scnr.resetPeek();\n    return ret;\n  }\n\n  function takeChar(scnr, fn) {\n    const ch = scnr.currentChar();\n\n    if (ch === EOF) {\n      return EOF;\n    }\n\n    if (fn(ch)) {\n      scnr.next();\n      return ch;\n    }\n\n    return null;\n  }\n\n  function takeIdentifierChar(scnr) {\n    const closure = ch => {\n      const cc = ch.charCodeAt(0);\n      return cc >= 97 && cc <= 122 || // a-z\n      cc >= 65 && cc <= 90 || // A-Z\n      cc >= 48 && cc <= 57 || // 0-9\n      cc === 95 || // _\n      cc === 36 // $\n      ;\n    };\n\n    return takeChar(scnr, closure);\n  }\n\n  function takeDigit(scnr) {\n    const closure = ch => {\n      const cc = ch.charCodeAt(0);\n      return cc >= 48 && cc <= 57; // 0-9\n    };\n\n    return takeChar(scnr, closure);\n  }\n\n  function takeHexDigit(scnr) {\n    const closure = ch => {\n      const cc = ch.charCodeAt(0);\n      return cc >= 48 && cc <= 57 || // 0-9\n      cc >= 65 && cc <= 70 || // A-F\n      cc >= 97 && cc <= 102; // a-f\n    };\n\n    return takeChar(scnr, closure);\n  }\n\n  function getDigits(scnr) {\n    let ch = '';\n    let num = '';\n\n    while (ch = takeDigit(scnr)) {\n      num += ch;\n    }\n\n    return num;\n  }\n\n  function readText(scnr) {\n    let buf = '';\n\n    while (true) {\n      const ch = scnr.currentChar();\n\n      if (ch === \"{\"\n      /* BraceLeft */\n      || ch === \"}\"\n      /* BraceRight */\n      || ch === \"@\"\n      /* LinkedAlias */\n      || ch === \"|\"\n      /* Pipe */\n      || !ch) {\n        break;\n      } else if (ch === \"%\"\n      /* Modulo */\n      ) {\n        if (isTextStart(scnr)) {\n          buf += ch;\n          scnr.next();\n        } else {\n          break;\n        }\n      } else if (ch === CHAR_SP || ch === CHAR_LF) {\n        if (isTextStart(scnr)) {\n          buf += ch;\n          scnr.next();\n        } else if (isPluralStart(scnr)) {\n          break;\n        } else {\n          buf += ch;\n          scnr.next();\n        }\n      } else {\n        buf += ch;\n        scnr.next();\n      }\n    }\n\n    return buf;\n  }\n\n  function readNamedIdentifier(scnr) {\n    skipSpaces(scnr);\n    let ch = '';\n    let name = '';\n\n    while (ch = takeIdentifierChar(scnr)) {\n      name += ch;\n    }\n\n    if (scnr.currentChar() === EOF) {\n      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n    }\n\n    return name;\n  }\n\n  function readListIdentifier(scnr) {\n    skipSpaces(scnr);\n    let value = '';\n\n    if (scnr.currentChar() === '-') {\n      scnr.next();\n      value += `-${getDigits(scnr)}`;\n    } else {\n      value += getDigits(scnr);\n    }\n\n    if (scnr.currentChar() === EOF) {\n      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n    }\n\n    return value;\n  }\n\n  function readLiteral(scnr) {\n    skipSpaces(scnr);\n    eat(scnr, `\\'`);\n    let ch = '';\n    let literal = '';\n\n    const fn = x => x !== LITERAL_DELIMITER && x !== CHAR_LF;\n\n    while (ch = takeChar(scnr, fn)) {\n      if (ch === '\\\\') {\n        literal += readEscapeSequence(scnr);\n      } else {\n        literal += ch;\n      }\n    }\n\n    const current = scnr.currentChar();\n\n    if (current === CHAR_LF || current === EOF) {\n      emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0); // TODO: Is it correct really?\n\n      if (current === CHAR_LF) {\n        scnr.next();\n        eat(scnr, `\\'`);\n      }\n\n      return literal;\n    }\n\n    eat(scnr, `\\'`);\n    return literal;\n  }\n\n  function readEscapeSequence(scnr) {\n    const ch = scnr.currentChar();\n\n    switch (ch) {\n      case '\\\\':\n      case `\\'`:\n        scnr.next();\n        return `\\\\${ch}`;\n\n      case 'u':\n        return readUnicodeEscapeSequence(scnr, ch, 4);\n\n      case 'U':\n        return readUnicodeEscapeSequence(scnr, ch, 6);\n\n      default:\n        emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);\n        return '';\n    }\n  }\n\n  function readUnicodeEscapeSequence(scnr, unicode, digits) {\n    eat(scnr, unicode);\n    let sequence = '';\n\n    for (let i = 0; i < digits; i++) {\n      const ch = takeHexDigit(scnr);\n\n      if (!ch) {\n        emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\\\${unicode}${sequence}${scnr.currentChar()}`);\n        break;\n      }\n\n      sequence += ch;\n    }\n\n    return `\\\\${unicode}${sequence}`;\n  }\n\n  function readInvalidIdentifier(scnr) {\n    skipSpaces(scnr);\n    let ch = '';\n    let identifiers = '';\n\n    const closure = ch => ch !== \"{\"\n    /* BraceLeft */\n    && ch !== \"}\"\n    /* BraceRight */\n    && ch !== CHAR_SP && ch !== CHAR_LF;\n\n    while (ch = takeChar(scnr, closure)) {\n      identifiers += ch;\n    }\n\n    return identifiers;\n  }\n\n  function readLinkedModifier(scnr) {\n    let ch = '';\n    let name = '';\n\n    while (ch = takeIdentifierChar(scnr)) {\n      name += ch;\n    }\n\n    return name;\n  }\n\n  function readLinkedRefer(scnr) {\n    const fn = (detect = false, buf) => {\n      const ch = scnr.currentChar();\n\n      if (ch === \"{\"\n      /* BraceLeft */\n      || ch === \"%\"\n      /* Modulo */\n      || ch === \"@\"\n      /* LinkedAlias */\n      || ch === \"|\"\n      /* Pipe */\n      || !ch) {\n        return buf;\n      } else if (ch === CHAR_SP) {\n        return buf;\n      } else if (ch === CHAR_LF) {\n        buf += ch;\n        scnr.next();\n        return fn(detect, buf);\n      } else {\n        buf += ch;\n        scnr.next();\n        return fn(true, buf);\n      }\n    };\n\n    return fn(false, '');\n  }\n\n  function readPlural(scnr) {\n    skipSpaces(scnr);\n    const plural = eat(scnr, \"|\"\n    /* Pipe */\n    );\n    skipSpaces(scnr);\n    return plural;\n  } // TODO: We need refactoring of token parsing ...\n\n\n  function readTokenInPlaceholder(scnr, context) {\n    let token = null;\n    const ch = scnr.currentChar();\n\n    switch (ch) {\n      case \"{\"\n      /* BraceLeft */\n      :\n        if (context.braceNest >= 1) {\n          emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);\n        }\n\n        scnr.next();\n        token = getToken(context, 2\n        /* BraceLeft */\n        , \"{\"\n        /* BraceLeft */\n        );\n        skipSpaces(scnr);\n        context.braceNest++;\n        return token;\n\n      case \"}\"\n      /* BraceRight */\n      :\n        if (context.braceNest > 0 && context.currentType === 2\n        /* BraceLeft */\n        ) {\n          emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);\n        }\n\n        scnr.next();\n        token = getToken(context, 3\n        /* BraceRight */\n        , \"}\"\n        /* BraceRight */\n        );\n        context.braceNest--;\n        context.braceNest > 0 && skipSpaces(scnr);\n\n        if (context.inLinked && context.braceNest === 0) {\n          context.inLinked = false;\n        }\n\n        return token;\n\n      case \"@\"\n      /* LinkedAlias */\n      :\n        if (context.braceNest > 0) {\n          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n        }\n\n        token = readTokenInLinked(scnr, context) || getEndToken(context);\n        context.braceNest = 0;\n        return token;\n\n      default:\n        let validNamedIdentifier = true;\n        let validListIdentifier = true;\n        let validLiteral = true;\n\n        if (isPluralStart(scnr)) {\n          if (context.braceNest > 0) {\n            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n          }\n\n          token = getToken(context, 1\n          /* Pipe */\n          , readPlural(scnr)); // reset\n\n          context.braceNest = 0;\n          context.inLinked = false;\n          return token;\n        }\n\n        if (context.braceNest > 0 && (context.currentType === 5\n        /* Named */\n        || context.currentType === 6\n        /* List */\n        || context.currentType === 7\n        /* Literal */\n        )) {\n          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n          context.braceNest = 0;\n          return readToken(scnr, context);\n        }\n\n        if (validNamedIdentifier = isNamedIdentifierStart(scnr, context)) {\n          token = getToken(context, 5\n          /* Named */\n          , readNamedIdentifier(scnr));\n          skipSpaces(scnr);\n          return token;\n        }\n\n        if (validListIdentifier = isListIdentifierStart(scnr, context)) {\n          token = getToken(context, 6\n          /* List */\n          , readListIdentifier(scnr));\n          skipSpaces(scnr);\n          return token;\n        }\n\n        if (validLiteral = isLiteralStart(scnr, context)) {\n          token = getToken(context, 7\n          /* Literal */\n          , readLiteral(scnr));\n          skipSpaces(scnr);\n          return token;\n        }\n\n        if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {\n          // TODO: we should be re-designed invalid cases, when we will extend message syntax near the future ...\n          token = getToken(context, 13\n          /* InvalidPlace */\n          , readInvalidIdentifier(scnr));\n          emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);\n          skipSpaces(scnr);\n          return token;\n        }\n\n        break;\n    }\n\n    return token;\n  } // TODO: We need refactoring of token parsing ...\n\n\n  function readTokenInLinked(scnr, context) {\n    const {\n      currentType\n    } = context;\n    let token = null;\n    const ch = scnr.currentChar();\n\n    if ((currentType === 8\n    /* LinkedAlias */\n    || currentType === 9\n    /* LinkedDot */\n    || currentType === 12\n    /* LinkedModifier */\n    || currentType === 10\n    /* LinkedDelimiter */\n    ) && (ch === CHAR_LF || ch === CHAR_SP)) {\n      emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);\n    }\n\n    switch (ch) {\n      case \"@\"\n      /* LinkedAlias */\n      :\n        scnr.next();\n        token = getToken(context, 8\n        /* LinkedAlias */\n        , \"@\"\n        /* LinkedAlias */\n        );\n        context.inLinked = true;\n        return token;\n\n      case \".\"\n      /* LinkedDot */\n      :\n        skipSpaces(scnr);\n        scnr.next();\n        return getToken(context, 9\n        /* LinkedDot */\n        , \".\"\n        /* LinkedDot */\n        );\n\n      case \":\"\n      /* LinkedDelimiter */\n      :\n        skipSpaces(scnr);\n        scnr.next();\n        return getToken(context, 10\n        /* LinkedDelimiter */\n        , \":\"\n        /* LinkedDelimiter */\n        );\n\n      default:\n        if (isPluralStart(scnr)) {\n          token = getToken(context, 1\n          /* Pipe */\n          , readPlural(scnr)); // reset\n\n          context.braceNest = 0;\n          context.inLinked = false;\n          return token;\n        }\n\n        if (isLinkedDotStart(scnr, context) || isLinkedDelimiterStart(scnr, context)) {\n          skipSpaces(scnr);\n          return readTokenInLinked(scnr, context);\n        }\n\n        if (isLinkedModifierStart(scnr, context)) {\n          skipSpaces(scnr);\n          return getToken(context, 12\n          /* LinkedModifier */\n          , readLinkedModifier(scnr));\n        }\n\n        if (isLinkedReferStart(scnr, context)) {\n          skipSpaces(scnr);\n\n          if (ch === \"{\"\n          /* BraceLeft */\n          ) {\n            // scan the placeholder\n            return readTokenInPlaceholder(scnr, context) || token;\n          } else {\n            return getToken(context, 11\n            /* LinkedKey */\n            , readLinkedRefer(scnr));\n          }\n        }\n\n        if (currentType === 8\n        /* LinkedAlias */\n        ) {\n          emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);\n        }\n\n        context.braceNest = 0;\n        context.inLinked = false;\n        return readToken(scnr, context);\n    }\n  } // TODO: We need refactoring of token parsing ...\n\n\n  function readToken(scnr, context) {\n    let token = {\n      type: 14\n      /* EOF */\n\n    };\n\n    if (context.braceNest > 0) {\n      return readTokenInPlaceholder(scnr, context) || getEndToken(context);\n    }\n\n    if (context.inLinked) {\n      return readTokenInLinked(scnr, context) || getEndToken(context);\n    }\n\n    const ch = scnr.currentChar();\n\n    switch (ch) {\n      case \"{\"\n      /* BraceLeft */\n      :\n        return readTokenInPlaceholder(scnr, context) || getEndToken(context);\n\n      case \"}\"\n      /* BraceRight */\n      :\n        emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);\n        scnr.next();\n        return getToken(context, 3\n        /* BraceRight */\n        , \"}\"\n        /* BraceRight */\n        );\n\n      case \"@\"\n      /* LinkedAlias */\n      :\n        return readTokenInLinked(scnr, context) || getEndToken(context);\n\n      default:\n        if (isPluralStart(scnr)) {\n          token = getToken(context, 1\n          /* Pipe */\n          , readPlural(scnr)); // reset\n\n          context.braceNest = 0;\n          context.inLinked = false;\n          return token;\n        }\n\n        if (isTextStart(scnr)) {\n          return getToken(context, 0\n          /* Text */\n          , readText(scnr));\n        }\n\n        if (ch === \"%\"\n        /* Modulo */\n        ) {\n          scnr.next();\n          return getToken(context, 4\n          /* Modulo */\n          , \"%\"\n          /* Modulo */\n          );\n        }\n\n        break;\n    }\n\n    return token;\n  }\n\n  function nextToken() {\n    const {\n      currentType,\n      offset,\n      startLoc,\n      endLoc\n    } = _context;\n    _context.lastType = currentType;\n    _context.lastOffset = offset;\n    _context.lastStartLoc = startLoc;\n    _context.lastEndLoc = endLoc;\n    _context.offset = currentOffset();\n    _context.startLoc = currentPosition();\n\n    if (_scnr.currentChar() === EOF) {\n      return getToken(_context, 14\n      /* EOF */\n      );\n    }\n\n    return readToken(_scnr, _context);\n  }\n\n  return {\n    nextToken,\n    currentOffset,\n    currentPosition,\n    context\n  };\n}\n\nconst ERROR_DOMAIN = 'parser'; // Backslash backslash, backslash quote, uHHHH, UHHHHHH.\n\nconst KNOWN_ESCAPES = /(?:\\\\\\\\|\\\\'|\\\\u([0-9a-fA-F]{4})|\\\\U([0-9a-fA-F]{6}))/g;\n\nfunction fromEscapeSequence(match, codePoint4, codePoint6) {\n  switch (match) {\n    case `\\\\\\\\`:\n      return `\\\\`;\n\n    case `\\\\\\'`:\n      return `\\'`;\n\n    default:\n      {\n        const codePoint = parseInt(codePoint4 || codePoint6, 16);\n\n        if (codePoint <= 0xd7ff || codePoint >= 0xe000) {\n          return String.fromCodePoint(codePoint);\n        } // invalid ...\n        // Replace them with U+FFFD REPLACEMENT CHARACTER.\n\n\n        return '�';\n      }\n  }\n}\n\nfunction createParser(options = {}) {\n  const location = options.location !== false;\n  const {\n    onError\n  } = options;\n\n  function emitError(tokenzer, code, start, offset, ...args) {\n    const end = tokenzer.currentPosition();\n    end.offset += offset;\n    end.column += offset;\n\n    if (onError) {\n      const loc = createLocation(start, end);\n      const err = createCompileError(code, loc, {\n        domain: ERROR_DOMAIN,\n        args\n      });\n      onError(err);\n    }\n  }\n\n  function startNode(type, offset, loc) {\n    const node = {\n      type,\n      start: offset,\n      end: offset\n    };\n\n    if (location) {\n      node.loc = {\n        start: loc,\n        end: loc\n      };\n    }\n\n    return node;\n  }\n\n  function endNode(node, offset, pos, type) {\n    node.end = offset;\n\n    if (type) {\n      node.type = type;\n    }\n\n    if (location && node.loc) {\n      node.loc.end = pos;\n    }\n  }\n\n  function parseText(tokenizer, value) {\n    const context = tokenizer.context();\n    const node = startNode(3\n    /* Text */\n    , context.offset, context.startLoc);\n    node.value = value;\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n\n  function parseList(tokenizer, index) {\n    const context = tokenizer.context();\n    const {\n      lastOffset: offset,\n      lastStartLoc: loc\n    } = context; // get brace left loc\n\n    const node = startNode(5\n    /* List */\n    , offset, loc);\n    node.index = parseInt(index, 10);\n    tokenizer.nextToken(); // skip brach right\n\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n\n  function parseNamed(tokenizer, key) {\n    const context = tokenizer.context();\n    const {\n      lastOffset: offset,\n      lastStartLoc: loc\n    } = context; // get brace left loc\n\n    const node = startNode(4\n    /* Named */\n    , offset, loc);\n    node.key = key;\n    tokenizer.nextToken(); // skip brach right\n\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n\n  function parseLiteral(tokenizer, value) {\n    const context = tokenizer.context();\n    const {\n      lastOffset: offset,\n      lastStartLoc: loc\n    } = context; // get brace left loc\n\n    const node = startNode(9\n    /* Literal */\n    , offset, loc);\n    node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);\n    tokenizer.nextToken(); // skip brach right\n\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n\n  function parseLinkedModifier(tokenizer) {\n    const token = tokenizer.nextToken();\n    const context = tokenizer.context();\n    const {\n      lastOffset: offset,\n      lastStartLoc: loc\n    } = context; // get linked dot loc\n\n    const node = startNode(8\n    /* LinkedModifier */\n    , offset, loc);\n\n    if (token.type !== 12\n    /* LinkedModifier */\n    ) {\n      // empty modifier\n      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);\n      node.value = '';\n      endNode(node, offset, loc);\n      return {\n        nextConsumeToken: token,\n        node\n      };\n    } // check token\n\n\n    if (token.value == null) {\n      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n    }\n\n    node.value = token.value || '';\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return {\n      node\n    };\n  }\n\n  function parseLinkedKey(tokenizer, value) {\n    const context = tokenizer.context();\n    const node = startNode(7\n    /* LinkedKey */\n    , context.offset, context.startLoc);\n    node.value = value;\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n\n  function parseLinked(tokenizer) {\n    const context = tokenizer.context();\n    const linkedNode = startNode(6\n    /* Linked */\n    , context.offset, context.startLoc);\n    let token = tokenizer.nextToken();\n\n    if (token.type === 9\n    /* LinkedDot */\n    ) {\n      const parsed = parseLinkedModifier(tokenizer);\n      linkedNode.modifier = parsed.node;\n      token = parsed.nextConsumeToken || tokenizer.nextToken();\n    } // asset check token\n\n\n    if (token.type !== 10\n    /* LinkedDelimiter */\n    ) {\n      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n    }\n\n    token = tokenizer.nextToken(); // skip brace left\n\n    if (token.type === 2\n    /* BraceLeft */\n    ) {\n      token = tokenizer.nextToken();\n    }\n\n    switch (token.type) {\n      case 11\n      /* LinkedKey */\n      :\n        if (token.value == null) {\n          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n\n        linkedNode.key = parseLinkedKey(tokenizer, token.value || '');\n        break;\n\n      case 5\n      /* Named */\n      :\n        if (token.value == null) {\n          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n\n        linkedNode.key = parseNamed(tokenizer, token.value || '');\n        break;\n\n      case 6\n      /* List */\n      :\n        if (token.value == null) {\n          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n\n        linkedNode.key = parseList(tokenizer, token.value || '');\n        break;\n\n      case 7\n      /* Literal */\n      :\n        if (token.value == null) {\n          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n\n        linkedNode.key = parseLiteral(tokenizer, token.value || '');\n        break;\n\n      default:\n        // empty key\n        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);\n        const nextContext = tokenizer.context();\n        const emptyLinkedKeyNode = startNode(7\n        /* LinkedKey */\n        , nextContext.offset, nextContext.startLoc);\n        emptyLinkedKeyNode.value = '';\n        endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);\n        linkedNode.key = emptyLinkedKeyNode;\n        endNode(linkedNode, nextContext.offset, nextContext.startLoc);\n        return {\n          nextConsumeToken: token,\n          node: linkedNode\n        };\n    }\n\n    endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return {\n      node: linkedNode\n    };\n  }\n\n  function parseMessage(tokenizer) {\n    const context = tokenizer.context();\n    const startOffset = context.currentType === 1\n    /* Pipe */\n    ? tokenizer.currentOffset() : context.offset;\n    const startLoc = context.currentType === 1\n    /* Pipe */\n    ? context.endLoc : context.startLoc;\n    const node = startNode(2\n    /* Message */\n    , startOffset, startLoc);\n    node.items = [];\n    let nextToken = null;\n\n    do {\n      const token = nextToken || tokenizer.nextToken();\n      nextToken = null;\n\n      switch (token.type) {\n        case 0\n        /* Text */\n        :\n          if (token.value == null) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n          }\n\n          node.items.push(parseText(tokenizer, token.value || ''));\n          break;\n\n        case 6\n        /* List */\n        :\n          if (token.value == null) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n          }\n\n          node.items.push(parseList(tokenizer, token.value || ''));\n          break;\n\n        case 5\n        /* Named */\n        :\n          if (token.value == null) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n          }\n\n          node.items.push(parseNamed(tokenizer, token.value || ''));\n          break;\n\n        case 7\n        /* Literal */\n        :\n          if (token.value == null) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n          }\n\n          node.items.push(parseLiteral(tokenizer, token.value || ''));\n          break;\n\n        case 8\n        /* LinkedAlias */\n        :\n          const parsed = parseLinked(tokenizer);\n          node.items.push(parsed.node);\n          nextToken = parsed.nextConsumeToken || null;\n          break;\n      }\n    } while (context.currentType !== 14\n    /* EOF */\n    && context.currentType !== 1\n    /* Pipe */\n    ); // adjust message node loc\n\n\n    const endOffset = context.currentType === 1\n    /* Pipe */\n    ? context.lastOffset : tokenizer.currentOffset();\n    const endLoc = context.currentType === 1\n    /* Pipe */\n    ? context.lastEndLoc : tokenizer.currentPosition();\n    endNode(node, endOffset, endLoc);\n    return node;\n  }\n\n  function parsePlural(tokenizer, offset, loc, msgNode) {\n    const context = tokenizer.context();\n    let hasEmptyMessage = msgNode.items.length === 0;\n    const node = startNode(1\n    /* Plural */\n    , offset, loc);\n    node.cases = [];\n    node.cases.push(msgNode);\n\n    do {\n      const msg = parseMessage(tokenizer);\n\n      if (!hasEmptyMessage) {\n        hasEmptyMessage = msg.items.length === 0;\n      }\n\n      node.cases.push(msg);\n    } while (context.currentType !== 14\n    /* EOF */\n    );\n\n    if (hasEmptyMessage) {\n      emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);\n    }\n\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n\n  function parseResource(tokenizer) {\n    const context = tokenizer.context();\n    const {\n      offset,\n      startLoc\n    } = context;\n    const msgNode = parseMessage(tokenizer);\n\n    if (context.currentType === 14\n    /* EOF */\n    ) {\n      return msgNode;\n    } else {\n      return parsePlural(tokenizer, offset, startLoc, msgNode);\n    }\n  }\n\n  function parse(source) {\n    const tokenizer = createTokenizer(source, assign({}, options));\n    const context = tokenizer.context();\n    const node = startNode(0\n    /* Resource */\n    , context.offset, context.startLoc);\n\n    if (location && node.loc) {\n      node.loc.source = source;\n    }\n\n    node.body = parseResource(tokenizer); // assert whether achieved to EOF\n\n    if (context.currentType !== 14\n    /* EOF */\n    ) {\n      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || '');\n    }\n\n    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n    return node;\n  }\n\n  return {\n    parse\n  };\n}\n\nfunction getTokenCaption(token) {\n  if (token.type === 14\n  /* EOF */\n  ) {\n    return 'EOF';\n  }\n\n  const name = (token.value || '').replace(/\\r?\\n/gu, '\\\\n');\n  return name.length > 10 ? name.slice(0, 9) + '…' : name;\n}\n\nfunction createTransformer(ast, options = {} // eslint-disable-line\n) {\n  const _context = {\n    ast,\n    helpers: new Set()\n  };\n\n  const context = () => _context;\n\n  const helper = name => {\n    _context.helpers.add(name);\n\n    return name;\n  };\n\n  return {\n    context,\n    helper\n  };\n}\n\nfunction traverseNodes(nodes, transformer) {\n  for (let i = 0; i < nodes.length; i++) {\n    traverseNode(nodes[i], transformer);\n  }\n}\n\nfunction traverseNode(node, transformer) {\n  // TODO: if we need pre-hook of transform, should be implemented to here\n  switch (node.type) {\n    case 1\n    /* Plural */\n    :\n      traverseNodes(node.cases, transformer);\n      transformer.helper(\"plural\"\n      /* PLURAL */\n      );\n      break;\n\n    case 2\n    /* Message */\n    :\n      traverseNodes(node.items, transformer);\n      break;\n\n    case 6\n    /* Linked */\n    :\n      const linked = node;\n      traverseNode(linked.key, transformer);\n      transformer.helper(\"linked\"\n      /* LINKED */\n      );\n      break;\n\n    case 5\n    /* List */\n    :\n      transformer.helper(\"interpolate\"\n      /* INTERPOLATE */\n      );\n      transformer.helper(\"list\"\n      /* LIST */\n      );\n      break;\n\n    case 4\n    /* Named */\n    :\n      transformer.helper(\"interpolate\"\n      /* INTERPOLATE */\n      );\n      transformer.helper(\"named\"\n      /* NAMED */\n      );\n      break;\n  } // TODO: if we need post-hook of transform, should be implemented to here\n\n} // transform AST\n\n\nfunction transform(ast, options = {} // eslint-disable-line\n) {\n  const transformer = createTransformer(ast);\n  transformer.helper(\"normalize\"\n  /* NORMALIZE */\n  ); // traverse\n\n  ast.body && traverseNode(ast.body, transformer); // set meta information\n\n  const context = transformer.context();\n  ast.helpers = Array.from(context.helpers);\n}\n\nfunction createCodeGenerator(ast, options) {\n  const {\n    sourceMap,\n    filename,\n    breakLineCode,\n    needIndent: _needIndent\n  } = options;\n  const _context = {\n    source: ast.loc.source,\n    filename,\n    code: '',\n    column: 1,\n    line: 1,\n    offset: 0,\n    map: undefined,\n    breakLineCode,\n    needIndent: _needIndent,\n    indentLevel: 0\n  };\n\n  const context = () => _context;\n\n  function push(code, node) {\n    _context.code += code;\n  }\n\n  function _newline(n, withBreakLine = true) {\n    const _breakLineCode = withBreakLine ? breakLineCode : '';\n\n    push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);\n  }\n\n  function indent(withNewLine = true) {\n    const level = ++_context.indentLevel;\n    withNewLine && _newline(level);\n  }\n\n  function deindent(withNewLine = true) {\n    const level = --_context.indentLevel;\n    withNewLine && _newline(level);\n  }\n\n  function newline() {\n    _newline(_context.indentLevel);\n  }\n\n  const helper = key => `_${key}`;\n\n  const needIndent = () => _context.needIndent;\n\n  return {\n    context,\n    push,\n    indent,\n    deindent,\n    newline,\n    helper,\n    needIndent\n  };\n}\n\nfunction generateLinkedNode(generator, node) {\n  const {\n    helper\n  } = generator;\n  generator.push(`${helper(\"linked\"\n  /* LINKED */\n  )}(`);\n  generateNode(generator, node.key);\n\n  if (node.modifier) {\n    generator.push(`, `);\n    generateNode(generator, node.modifier);\n  }\n\n  generator.push(`)`);\n}\n\nfunction generateMessageNode(generator, node) {\n  const {\n    helper,\n    needIndent\n  } = generator;\n  generator.push(`${helper(\"normalize\"\n  /* NORMALIZE */\n  )}([`);\n  generator.indent(needIndent());\n  const length = node.items.length;\n\n  for (let i = 0; i < length; i++) {\n    generateNode(generator, node.items[i]);\n\n    if (i === length - 1) {\n      break;\n    }\n\n    generator.push(', ');\n  }\n\n  generator.deindent(needIndent());\n  generator.push('])');\n}\n\nfunction generatePluralNode(generator, node) {\n  const {\n    helper,\n    needIndent\n  } = generator;\n\n  if (node.cases.length > 1) {\n    generator.push(`${helper(\"plural\"\n    /* PLURAL */\n    )}([`);\n    generator.indent(needIndent());\n    const length = node.cases.length;\n\n    for (let i = 0; i < length; i++) {\n      generateNode(generator, node.cases[i]);\n\n      if (i === length - 1) {\n        break;\n      }\n\n      generator.push(', ');\n    }\n\n    generator.deindent(needIndent());\n    generator.push(`])`);\n  }\n}\n\nfunction generateResource(generator, node) {\n  if (node.body) {\n    generateNode(generator, node.body);\n  } else {\n    generator.push('null');\n  }\n}\n\nfunction generateNode(generator, node) {\n  const {\n    helper\n  } = generator;\n\n  switch (node.type) {\n    case 0\n    /* Resource */\n    :\n      generateResource(generator, node);\n      break;\n\n    case 1\n    /* Plural */\n    :\n      generatePluralNode(generator, node);\n      break;\n\n    case 2\n    /* Message */\n    :\n      generateMessageNode(generator, node);\n      break;\n\n    case 6\n    /* Linked */\n    :\n      generateLinkedNode(generator, node);\n      break;\n\n    case 8\n    /* LinkedModifier */\n    :\n      generator.push(JSON.stringify(node.value), node);\n      break;\n\n    case 7\n    /* LinkedKey */\n    :\n      generator.push(JSON.stringify(node.value), node);\n      break;\n\n    case 5\n    /* List */\n    :\n      generator.push(`${helper(\"interpolate\"\n      /* INTERPOLATE */\n      )}(${helper(\"list\"\n      /* LIST */\n      )}(${node.index}))`, node);\n      break;\n\n    case 4\n    /* Named */\n    :\n      generator.push(`${helper(\"interpolate\"\n      /* INTERPOLATE */\n      )}(${helper(\"named\"\n      /* NAMED */\n      )}(${JSON.stringify(node.key)}))`, node);\n      break;\n\n    case 9\n    /* Literal */\n    :\n      generator.push(JSON.stringify(node.value), node);\n      break;\n\n    case 3\n    /* Text */\n    :\n      generator.push(JSON.stringify(node.value), node);\n      break;\n\n    default:\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error(`unhandled codegen node type: ${node.type}`);\n      }\n\n  }\n} // generate code from AST\n\n\nconst generate = (ast, options = {} // eslint-disable-line\n) => {\n  const mode = isString(options.mode) ? options.mode : 'normal';\n  const filename = isString(options.filename) ? options.filename : 'message.intl';\n  const sourceMap = !!options.sourceMap; // prettier-ignore\n\n  const breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === 'arrow' ? ';' : '\\n';\n  const needIndent = options.needIndent ? options.needIndent : mode !== 'arrow';\n  const helpers = ast.helpers || [];\n  const generator = createCodeGenerator(ast, {\n    mode,\n    filename,\n    sourceMap,\n    breakLineCode,\n    needIndent\n  });\n  generator.push(mode === 'normal' ? `function __msg__ (ctx) {` : `(ctx) => {`);\n  generator.indent(needIndent);\n\n  if (helpers.length > 0) {\n    generator.push(`const { ${helpers.map(s => `${s}: _${s}`).join(', ')} } = ctx`);\n    generator.newline();\n  }\n\n  generator.push(`return `);\n  generateNode(generator, ast);\n  generator.deindent(needIndent);\n  generator.push(`}`);\n  const {\n    code,\n    map\n  } = generator.context();\n  return {\n    ast,\n    code,\n    map: map ? map.toJSON() : undefined // eslint-disable-line @typescript-eslint/no-explicit-any\n\n  };\n};\n\nfunction baseCompile(source, options = {}) {\n  const assignedOptions = assign({}, options); // parse source codes\n\n  const parser = createParser(assignedOptions);\n  const ast = parser.parse(source); // transform ASTs\n\n  transform(ast, assignedOptions); // generate javascript codes\n\n  return generate(ast, assignedOptions);\n}\n\nexport { CompileErrorCodes, ERROR_DOMAIN, LocationStub, baseCompile, createCompileError, createLocation, createParser, createPosition, defaultOnError, errorMessages };","map":{"version":3,"sources":["/home/lisoleg/checkers/vue/node_modules/@intlify/message-compiler/dist/message-compiler.esm-bundler.js"],"names":["format","assign","isString","CompileErrorCodes","EXPECTED_TOKEN","INVALID_TOKEN_IN_PLACEHOLDER","UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER","UNKNOWN_ESCAPE_SEQUENCE","INVALID_UNICODE_ESCAPE_SEQUENCE","UNBALANCED_CLOSING_BRACE","UNTERMINATED_CLOSING_BRACE","EMPTY_PLACEHOLDER","NOT_ALLOW_NEST_PLACEHOLDER","INVALID_LINKED_FORMAT","MUST_HAVE_MESSAGES_IN_PLURAL","UNEXPECTED_EMPTY_LINKED_MODIFIER","UNEXPECTED_EMPTY_LINKED_KEY","UNEXPECTED_LEXICAL_ANALYSIS","__EXTEND_POINT__","errorMessages","createCompileError","code","loc","options","domain","messages","args","msg","process","env","NODE_ENV","error","SyntaxError","String","location","defaultOnError","LocationStub","start","line","column","offset","end","createPosition","createLocation","source","CHAR_SP","CHAR_CR","CHAR_LF","CHAR_LS","fromCharCode","CHAR_PS","createScanner","str","_buf","_index","_line","_column","_peekOffset","isCRLF","index","isLF","isPS","isLS","isLineEnd","peekOffset","charAt","currentChar","currentPeek","next","peek","reset","resetPeek","skipToPeek","target","EOF","undefined","LITERAL_DELIMITER","ERROR_DOMAIN$1","createTokenizer","_scnr","currentOffset","currentPosition","_initLoc","_initOffset","_context","currentType","startLoc","endLoc","lastType","lastOffset","lastStartLoc","lastEndLoc","braceNest","inLinked","text","context","onError","emitError","pos","ctx","err","getToken","type","value","token","getEndToken","eat","scnr","ch","peekSpaces","buf","skipSpaces","isIdentifierStart","cc","charCodeAt","isNumberStart","isNamedIdentifierStart","ret","isListIdentifierStart","isLiteralStart","isLinkedDotStart","isLinkedModifierStart","isLinkedDelimiterStart","isLinkedReferStart","fn","isPluralStart","isTextStart","hasSpace","prev","detectModulo","takeChar","takeIdentifierChar","closure","takeDigit","takeHexDigit","getDigits","num","readText","readNamedIdentifier","name","readListIdentifier","readLiteral","literal","x","readEscapeSequence","current","readUnicodeEscapeSequence","unicode","digits","sequence","i","readInvalidIdentifier","identifiers","readLinkedModifier","readLinkedRefer","detect","readPlural","plural","readTokenInPlaceholder","readTokenInLinked","validNamedIdentifier","validListIdentifier","validLiteral","readToken","nextToken","ERROR_DOMAIN","KNOWN_ESCAPES","fromEscapeSequence","match","codePoint4","codePoint6","codePoint","parseInt","fromCodePoint","createParser","tokenzer","startNode","node","endNode","parseText","tokenizer","parseList","parseNamed","key","parseLiteral","replace","parseLinkedModifier","nextConsumeToken","getTokenCaption","parseLinkedKey","parseLinked","linkedNode","parsed","modifier","nextContext","emptyLinkedKeyNode","parseMessage","startOffset","items","push","endOffset","parsePlural","msgNode","hasEmptyMessage","length","cases","parseResource","parse","body","slice","createTransformer","ast","helpers","Set","helper","add","traverseNodes","nodes","transformer","traverseNode","linked","transform","Array","from","createCodeGenerator","sourceMap","filename","breakLineCode","needIndent","_needIndent","map","indentLevel","_newline","n","withBreakLine","_breakLineCode","repeat","indent","withNewLine","level","deindent","newline","generateLinkedNode","generator","generateNode","generateMessageNode","generatePluralNode","generateResource","JSON","stringify","Error","generate","mode","s","join","toJSON","baseCompile","assignedOptions","parser"],"mappings":"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","sourcesContent":["/*!\n  * message-compiler v9.2.0-beta.26\n  * (c) 2021 kazuya kawaguchi\n  * Released under the MIT License.\n  */\nimport { format, assign, isString } from '@intlify/shared';\n\nconst CompileErrorCodes = {\r\n    // tokenizer error codes\r\n    EXPECTED_TOKEN: 1,\r\n    INVALID_TOKEN_IN_PLACEHOLDER: 2,\r\n    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,\r\n    UNKNOWN_ESCAPE_SEQUENCE: 4,\r\n    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,\r\n    UNBALANCED_CLOSING_BRACE: 6,\r\n    UNTERMINATED_CLOSING_BRACE: 7,\r\n    EMPTY_PLACEHOLDER: 8,\r\n    NOT_ALLOW_NEST_PLACEHOLDER: 9,\r\n    INVALID_LINKED_FORMAT: 10,\r\n    // parser error codes\r\n    MUST_HAVE_MESSAGES_IN_PLURAL: 11,\r\n    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,\r\n    UNEXPECTED_EMPTY_LINKED_KEY: 13,\r\n    UNEXPECTED_LEXICAL_ANALYSIS: 14,\r\n    // Special value for higher-order compilers to pick up the last code\r\n    // to avoid collision of error codes. This should always be kept as the last\r\n    // item.\r\n    __EXTEND_POINT__: 15\r\n};\r\n/** @internal */\r\nconst errorMessages = {\r\n    // tokenizer error messages\r\n    [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,\r\n    [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,\r\n    [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,\r\n    [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\\\{0}`,\r\n    [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,\r\n    [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,\r\n    [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,\r\n    [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,\r\n    [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,\r\n    [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,\r\n    // parser error messages\r\n    [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,\r\n    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,\r\n    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,\r\n    [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`\r\n};\r\nfunction createCompileError(code, loc, options = {}) {\r\n    const { domain, messages, args } = options;\r\n    const msg = (process.env.NODE_ENV !== 'production')\r\n        ? format((messages || errorMessages)[code] || '', ...(args || []))\r\n        : code;\r\n    const error = new SyntaxError(String(msg));\r\n    error.code = code;\r\n    if (loc) {\r\n        error.location = loc;\r\n    }\r\n    error.domain = domain;\r\n    return error;\r\n}\r\n/** @internal */\r\nfunction defaultOnError(error) {\r\n    throw error;\r\n}\n\nconst LocationStub = {\r\n    start: { line: 1, column: 1, offset: 0 },\r\n    end: { line: 1, column: 1, offset: 0 }\r\n};\r\nfunction createPosition(line, column, offset) {\r\n    return { line, column, offset };\r\n}\r\nfunction createLocation(start, end, source) {\r\n    const loc = { start, end };\r\n    if (source != null) {\r\n        loc.source = source;\r\n    }\r\n    return loc;\r\n}\n\nconst CHAR_SP = ' ';\r\nconst CHAR_CR = '\\r';\r\nconst CHAR_LF = '\\n';\r\nconst CHAR_LS = String.fromCharCode(0x2028);\r\nconst CHAR_PS = String.fromCharCode(0x2029);\r\nfunction createScanner(str) {\r\n    const _buf = str;\r\n    let _index = 0;\r\n    let _line = 1;\r\n    let _column = 1;\r\n    let _peekOffset = 0;\r\n    const isCRLF = (index) => _buf[index] === CHAR_CR && _buf[index + 1] === CHAR_LF;\r\n    const isLF = (index) => _buf[index] === CHAR_LF;\r\n    const isPS = (index) => _buf[index] === CHAR_PS;\r\n    const isLS = (index) => _buf[index] === CHAR_LS;\r\n    const isLineEnd = (index) => isCRLF(index) || isLF(index) || isPS(index) || isLS(index);\r\n    const index = () => _index;\r\n    const line = () => _line;\r\n    const column = () => _column;\r\n    const peekOffset = () => _peekOffset;\r\n    const charAt = (offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];\r\n    const currentChar = () => charAt(_index);\r\n    const currentPeek = () => charAt(_index + _peekOffset);\r\n    function next() {\r\n        _peekOffset = 0;\r\n        if (isLineEnd(_index)) {\r\n            _line++;\r\n            _column = 0;\r\n        }\r\n        if (isCRLF(_index)) {\r\n            _index++;\r\n        }\r\n        _index++;\r\n        _column++;\r\n        return _buf[_index];\r\n    }\r\n    function peek() {\r\n        if (isCRLF(_index + _peekOffset)) {\r\n            _peekOffset++;\r\n        }\r\n        _peekOffset++;\r\n        return _buf[_index + _peekOffset];\r\n    }\r\n    function reset() {\r\n        _index = 0;\r\n        _line = 1;\r\n        _column = 1;\r\n        _peekOffset = 0;\r\n    }\r\n    function resetPeek(offset = 0) {\r\n        _peekOffset = offset;\r\n    }\r\n    function skipToPeek() {\r\n        const target = _index + _peekOffset;\r\n        // eslint-disable-next-line no-unmodified-loop-condition\r\n        while (target !== _index) {\r\n            next();\r\n        }\r\n        _peekOffset = 0;\r\n    }\r\n    return {\r\n        index,\r\n        line,\r\n        column,\r\n        peekOffset,\r\n        charAt,\r\n        currentChar,\r\n        currentPeek,\r\n        next,\r\n        peek,\r\n        reset,\r\n        resetPeek,\r\n        skipToPeek\r\n    };\r\n}\n\nconst EOF = undefined;\r\nconst LITERAL_DELIMITER = \"'\";\r\nconst ERROR_DOMAIN$1 = 'tokenizer';\r\nfunction createTokenizer(source, options = {}) {\r\n    const location = options.location !== false;\r\n    const _scnr = createScanner(source);\r\n    const currentOffset = () => _scnr.index();\r\n    const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());\r\n    const _initLoc = currentPosition();\r\n    const _initOffset = currentOffset();\r\n    const _context = {\r\n        currentType: 14 /* EOF */,\r\n        offset: _initOffset,\r\n        startLoc: _initLoc,\r\n        endLoc: _initLoc,\r\n        lastType: 14 /* EOF */,\r\n        lastOffset: _initOffset,\r\n        lastStartLoc: _initLoc,\r\n        lastEndLoc: _initLoc,\r\n        braceNest: 0,\r\n        inLinked: false,\r\n        text: ''\r\n    };\r\n    const context = () => _context;\r\n    const { onError } = options;\r\n    function emitError(code, pos, offset, ...args) {\r\n        const ctx = context();\r\n        pos.column += offset;\r\n        pos.offset += offset;\r\n        if (onError) {\r\n            const loc = createLocation(ctx.startLoc, pos);\r\n            const err = createCompileError(code, loc, {\r\n                domain: ERROR_DOMAIN$1,\r\n                args\r\n            });\r\n            onError(err);\r\n        }\r\n    }\r\n    function getToken(context, type, value) {\r\n        context.endLoc = currentPosition();\r\n        context.currentType = type;\r\n        const token = { type };\r\n        if (location) {\r\n            token.loc = createLocation(context.startLoc, context.endLoc);\r\n        }\r\n        if (value != null) {\r\n            token.value = value;\r\n        }\r\n        return token;\r\n    }\r\n    const getEndToken = (context) => getToken(context, 14 /* EOF */);\r\n    function eat(scnr, ch) {\r\n        if (scnr.currentChar() === ch) {\r\n            scnr.next();\r\n            return ch;\r\n        }\r\n        else {\r\n            emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);\r\n            return '';\r\n        }\r\n    }\r\n    function peekSpaces(scnr) {\r\n        let buf = '';\r\n        while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {\r\n            buf += scnr.currentPeek();\r\n            scnr.peek();\r\n        }\r\n        return buf;\r\n    }\r\n    function skipSpaces(scnr) {\r\n        const buf = peekSpaces(scnr);\r\n        scnr.skipToPeek();\r\n        return buf;\r\n    }\r\n    function isIdentifierStart(ch) {\r\n        if (ch === EOF) {\r\n            return false;\r\n        }\r\n        const cc = ch.charCodeAt(0);\r\n        return ((cc >= 97 && cc <= 122) || // a-z\r\n            (cc >= 65 && cc <= 90) || // A-Z\r\n            cc === 95 // _\r\n        );\r\n    }\r\n    function isNumberStart(ch) {\r\n        if (ch === EOF) {\r\n            return false;\r\n        }\r\n        const cc = ch.charCodeAt(0);\r\n        return cc >= 48 && cc <= 57; // 0-9\r\n    }\r\n    function isNamedIdentifierStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (currentType !== 2 /* BraceLeft */) {\r\n            return false;\r\n        }\r\n        peekSpaces(scnr);\r\n        const ret = isIdentifierStart(scnr.currentPeek());\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isListIdentifierStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (currentType !== 2 /* BraceLeft */) {\r\n            return false;\r\n        }\r\n        peekSpaces(scnr);\r\n        const ch = scnr.currentPeek() === '-' ? scnr.peek() : scnr.currentPeek();\r\n        const ret = isNumberStart(ch);\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isLiteralStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (currentType !== 2 /* BraceLeft */) {\r\n            return false;\r\n        }\r\n        peekSpaces(scnr);\r\n        const ret = scnr.currentPeek() === LITERAL_DELIMITER;\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isLinkedDotStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (currentType !== 8 /* LinkedAlias */) {\r\n            return false;\r\n        }\r\n        peekSpaces(scnr);\r\n        const ret = scnr.currentPeek() === \".\" /* LinkedDot */;\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isLinkedModifierStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (currentType !== 9 /* LinkedDot */) {\r\n            return false;\r\n        }\r\n        peekSpaces(scnr);\r\n        const ret = isIdentifierStart(scnr.currentPeek());\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isLinkedDelimiterStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (!(currentType === 8 /* LinkedAlias */ ||\r\n            currentType === 12 /* LinkedModifier */)) {\r\n            return false;\r\n        }\r\n        peekSpaces(scnr);\r\n        const ret = scnr.currentPeek() === \":\" /* LinkedDelimiter */;\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isLinkedReferStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (currentType !== 10 /* LinkedDelimiter */) {\r\n            return false;\r\n        }\r\n        const fn = () => {\r\n            const ch = scnr.currentPeek();\r\n            if (ch === \"{\" /* BraceLeft */) {\r\n                return isIdentifierStart(scnr.peek());\r\n            }\r\n            else if (ch === \"@\" /* LinkedAlias */ ||\r\n                ch === \"%\" /* Modulo */ ||\r\n                ch === \"|\" /* Pipe */ ||\r\n                ch === \":\" /* LinkedDelimiter */ ||\r\n                ch === \".\" /* LinkedDot */ ||\r\n                ch === CHAR_SP ||\r\n                !ch) {\r\n                return false;\r\n            }\r\n            else if (ch === CHAR_LF) {\r\n                scnr.peek();\r\n                return fn();\r\n            }\r\n            else {\r\n                // other characters\r\n                return isIdentifierStart(ch);\r\n            }\r\n        };\r\n        const ret = fn();\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isPluralStart(scnr) {\r\n        peekSpaces(scnr);\r\n        const ret = scnr.currentPeek() === \"|\" /* Pipe */;\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isTextStart(scnr, reset = true) {\r\n        const fn = (hasSpace = false, prev = '', detectModulo = false) => {\r\n            const ch = scnr.currentPeek();\r\n            if (ch === \"{\" /* BraceLeft */) {\r\n                return prev === \"%\" /* Modulo */ ? false : hasSpace;\r\n            }\r\n            else if (ch === \"@\" /* LinkedAlias */ || !ch) {\r\n                return prev === \"%\" /* Modulo */ ? true : hasSpace;\r\n            }\r\n            else if (ch === \"%\" /* Modulo */) {\r\n                scnr.peek();\r\n                return fn(hasSpace, \"%\" /* Modulo */, true);\r\n            }\r\n            else if (ch === \"|\" /* Pipe */) {\r\n                return prev === \"%\" /* Modulo */ || detectModulo\r\n                    ? true\r\n                    : !(prev === CHAR_SP || prev === CHAR_LF);\r\n            }\r\n            else if (ch === CHAR_SP) {\r\n                scnr.peek();\r\n                return fn(true, CHAR_SP, detectModulo);\r\n            }\r\n            else if (ch === CHAR_LF) {\r\n                scnr.peek();\r\n                return fn(true, CHAR_LF, detectModulo);\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        };\r\n        const ret = fn();\r\n        reset && scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function takeChar(scnr, fn) {\r\n        const ch = scnr.currentChar();\r\n        if (ch === EOF) {\r\n            return EOF;\r\n        }\r\n        if (fn(ch)) {\r\n            scnr.next();\r\n            return ch;\r\n        }\r\n        return null;\r\n    }\r\n    function takeIdentifierChar(scnr) {\r\n        const closure = (ch) => {\r\n            const cc = ch.charCodeAt(0);\r\n            return ((cc >= 97 && cc <= 122) || // a-z\r\n                (cc >= 65 && cc <= 90) || // A-Z\r\n                (cc >= 48 && cc <= 57) || // 0-9\r\n                cc === 95 || // _\r\n                cc === 36 // $\r\n            );\r\n        };\r\n        return takeChar(scnr, closure);\r\n    }\r\n    function takeDigit(scnr) {\r\n        const closure = (ch) => {\r\n            const cc = ch.charCodeAt(0);\r\n            return cc >= 48 && cc <= 57; // 0-9\r\n        };\r\n        return takeChar(scnr, closure);\r\n    }\r\n    function takeHexDigit(scnr) {\r\n        const closure = (ch) => {\r\n            const cc = ch.charCodeAt(0);\r\n            return ((cc >= 48 && cc <= 57) || // 0-9\r\n                (cc >= 65 && cc <= 70) || // A-F\r\n                (cc >= 97 && cc <= 102)); // a-f\r\n        };\r\n        return takeChar(scnr, closure);\r\n    }\r\n    function getDigits(scnr) {\r\n        let ch = '';\r\n        let num = '';\r\n        while ((ch = takeDigit(scnr))) {\r\n            num += ch;\r\n        }\r\n        return num;\r\n    }\r\n    function readText(scnr) {\r\n        let buf = '';\r\n        while (true) {\r\n            const ch = scnr.currentChar();\r\n            if (ch === \"{\" /* BraceLeft */ ||\r\n                ch === \"}\" /* BraceRight */ ||\r\n                ch === \"@\" /* LinkedAlias */ ||\r\n                ch === \"|\" /* Pipe */ ||\r\n                !ch) {\r\n                break;\r\n            }\r\n            else if (ch === \"%\" /* Modulo */) {\r\n                if (isTextStart(scnr)) {\r\n                    buf += ch;\r\n                    scnr.next();\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            else if (ch === CHAR_SP || ch === CHAR_LF) {\r\n                if (isTextStart(scnr)) {\r\n                    buf += ch;\r\n                    scnr.next();\r\n                }\r\n                else if (isPluralStart(scnr)) {\r\n                    break;\r\n                }\r\n                else {\r\n                    buf += ch;\r\n                    scnr.next();\r\n                }\r\n            }\r\n            else {\r\n                buf += ch;\r\n                scnr.next();\r\n            }\r\n        }\r\n        return buf;\r\n    }\r\n    function readNamedIdentifier(scnr) {\r\n        skipSpaces(scnr);\r\n        let ch = '';\r\n        let name = '';\r\n        while ((ch = takeIdentifierChar(scnr))) {\r\n            name += ch;\r\n        }\r\n        if (scnr.currentChar() === EOF) {\r\n            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\r\n        }\r\n        return name;\r\n    }\r\n    function readListIdentifier(scnr) {\r\n        skipSpaces(scnr);\r\n        let value = '';\r\n        if (scnr.currentChar() === '-') {\r\n            scnr.next();\r\n            value += `-${getDigits(scnr)}`;\r\n        }\r\n        else {\r\n            value += getDigits(scnr);\r\n        }\r\n        if (scnr.currentChar() === EOF) {\r\n            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\r\n        }\r\n        return value;\r\n    }\r\n    function readLiteral(scnr) {\r\n        skipSpaces(scnr);\r\n        eat(scnr, `\\'`);\r\n        let ch = '';\r\n        let literal = '';\r\n        const fn = (x) => x !== LITERAL_DELIMITER && x !== CHAR_LF;\r\n        while ((ch = takeChar(scnr, fn))) {\r\n            if (ch === '\\\\') {\r\n                literal += readEscapeSequence(scnr);\r\n            }\r\n            else {\r\n                literal += ch;\r\n            }\r\n        }\r\n        const current = scnr.currentChar();\r\n        if (current === CHAR_LF || current === EOF) {\r\n            emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);\r\n            // TODO: Is it correct really?\r\n            if (current === CHAR_LF) {\r\n                scnr.next();\r\n                eat(scnr, `\\'`);\r\n            }\r\n            return literal;\r\n        }\r\n        eat(scnr, `\\'`);\r\n        return literal;\r\n    }\r\n    function readEscapeSequence(scnr) {\r\n        const ch = scnr.currentChar();\r\n        switch (ch) {\r\n            case '\\\\':\r\n            case `\\'`:\r\n                scnr.next();\r\n                return `\\\\${ch}`;\r\n            case 'u':\r\n                return readUnicodeEscapeSequence(scnr, ch, 4);\r\n            case 'U':\r\n                return readUnicodeEscapeSequence(scnr, ch, 6);\r\n            default:\r\n                emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);\r\n                return '';\r\n        }\r\n    }\r\n    function readUnicodeEscapeSequence(scnr, unicode, digits) {\r\n        eat(scnr, unicode);\r\n        let sequence = '';\r\n        for (let i = 0; i < digits; i++) {\r\n            const ch = takeHexDigit(scnr);\r\n            if (!ch) {\r\n                emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\\\${unicode}${sequence}${scnr.currentChar()}`);\r\n                break;\r\n            }\r\n            sequence += ch;\r\n        }\r\n        return `\\\\${unicode}${sequence}`;\r\n    }\r\n    function readInvalidIdentifier(scnr) {\r\n        skipSpaces(scnr);\r\n        let ch = '';\r\n        let identifiers = '';\r\n        const closure = (ch) => ch !== \"{\" /* BraceLeft */ &&\r\n            ch !== \"}\" /* BraceRight */ &&\r\n            ch !== CHAR_SP &&\r\n            ch !== CHAR_LF;\r\n        while ((ch = takeChar(scnr, closure))) {\r\n            identifiers += ch;\r\n        }\r\n        return identifiers;\r\n    }\r\n    function readLinkedModifier(scnr) {\r\n        let ch = '';\r\n        let name = '';\r\n        while ((ch = takeIdentifierChar(scnr))) {\r\n            name += ch;\r\n        }\r\n        return name;\r\n    }\r\n    function readLinkedRefer(scnr) {\r\n        const fn = (detect = false, buf) => {\r\n            const ch = scnr.currentChar();\r\n            if (ch === \"{\" /* BraceLeft */ ||\r\n                ch === \"%\" /* Modulo */ ||\r\n                ch === \"@\" /* LinkedAlias */ ||\r\n                ch === \"|\" /* Pipe */ ||\r\n                !ch) {\r\n                return buf;\r\n            }\r\n            else if (ch === CHAR_SP) {\r\n                return buf;\r\n            }\r\n            else if (ch === CHAR_LF) {\r\n                buf += ch;\r\n                scnr.next();\r\n                return fn(detect, buf);\r\n            }\r\n            else {\r\n                buf += ch;\r\n                scnr.next();\r\n                return fn(true, buf);\r\n            }\r\n        };\r\n        return fn(false, '');\r\n    }\r\n    function readPlural(scnr) {\r\n        skipSpaces(scnr);\r\n        const plural = eat(scnr, \"|\" /* Pipe */);\r\n        skipSpaces(scnr);\r\n        return plural;\r\n    }\r\n    // TODO: We need refactoring of token parsing ...\r\n    function readTokenInPlaceholder(scnr, context) {\r\n        let token = null;\r\n        const ch = scnr.currentChar();\r\n        switch (ch) {\r\n            case \"{\" /* BraceLeft */:\r\n                if (context.braceNest >= 1) {\r\n                    emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);\r\n                }\r\n                scnr.next();\r\n                token = getToken(context, 2 /* BraceLeft */, \"{\" /* BraceLeft */);\r\n                skipSpaces(scnr);\r\n                context.braceNest++;\r\n                return token;\r\n            case \"}\" /* BraceRight */:\r\n                if (context.braceNest > 0 &&\r\n                    context.currentType === 2 /* BraceLeft */) {\r\n                    emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);\r\n                }\r\n                scnr.next();\r\n                token = getToken(context, 3 /* BraceRight */, \"}\" /* BraceRight */);\r\n                context.braceNest--;\r\n                context.braceNest > 0 && skipSpaces(scnr);\r\n                if (context.inLinked && context.braceNest === 0) {\r\n                    context.inLinked = false;\r\n                }\r\n                return token;\r\n            case \"@\" /* LinkedAlias */:\r\n                if (context.braceNest > 0) {\r\n                    emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\r\n                }\r\n                token = readTokenInLinked(scnr, context) || getEndToken(context);\r\n                context.braceNest = 0;\r\n                return token;\r\n            default:\r\n                let validNamedIdentifier = true;\r\n                let validListIdentifier = true;\r\n                let validLiteral = true;\r\n                if (isPluralStart(scnr)) {\r\n                    if (context.braceNest > 0) {\r\n                        emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\r\n                    }\r\n                    token = getToken(context, 1 /* Pipe */, readPlural(scnr));\r\n                    // reset\r\n                    context.braceNest = 0;\r\n                    context.inLinked = false;\r\n                    return token;\r\n                }\r\n                if (context.braceNest > 0 &&\r\n                    (context.currentType === 5 /* Named */ ||\r\n                        context.currentType === 6 /* List */ ||\r\n                        context.currentType === 7 /* Literal */)) {\r\n                    emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\r\n                    context.braceNest = 0;\r\n                    return readToken(scnr, context);\r\n                }\r\n                if ((validNamedIdentifier = isNamedIdentifierStart(scnr, context))) {\r\n                    token = getToken(context, 5 /* Named */, readNamedIdentifier(scnr));\r\n                    skipSpaces(scnr);\r\n                    return token;\r\n                }\r\n                if ((validListIdentifier = isListIdentifierStart(scnr, context))) {\r\n                    token = getToken(context, 6 /* List */, readListIdentifier(scnr));\r\n                    skipSpaces(scnr);\r\n                    return token;\r\n                }\r\n                if ((validLiteral = isLiteralStart(scnr, context))) {\r\n                    token = getToken(context, 7 /* Literal */, readLiteral(scnr));\r\n                    skipSpaces(scnr);\r\n                    return token;\r\n                }\r\n                if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {\r\n                    // TODO: we should be re-designed invalid cases, when we will extend message syntax near the future ...\r\n                    token = getToken(context, 13 /* InvalidPlace */, readInvalidIdentifier(scnr));\r\n                    emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);\r\n                    skipSpaces(scnr);\r\n                    return token;\r\n                }\r\n                break;\r\n        }\r\n        return token;\r\n    }\r\n    // TODO: We need refactoring of token parsing ...\r\n    function readTokenInLinked(scnr, context) {\r\n        const { currentType } = context;\r\n        let token = null;\r\n        const ch = scnr.currentChar();\r\n        if ((currentType === 8 /* LinkedAlias */ ||\r\n            currentType === 9 /* LinkedDot */ ||\r\n            currentType === 12 /* LinkedModifier */ ||\r\n            currentType === 10 /* LinkedDelimiter */) &&\r\n            (ch === CHAR_LF || ch === CHAR_SP)) {\r\n            emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);\r\n        }\r\n        switch (ch) {\r\n            case \"@\" /* LinkedAlias */:\r\n                scnr.next();\r\n                token = getToken(context, 8 /* LinkedAlias */, \"@\" /* LinkedAlias */);\r\n                context.inLinked = true;\r\n                return token;\r\n            case \".\" /* LinkedDot */:\r\n                skipSpaces(scnr);\r\n                scnr.next();\r\n                return getToken(context, 9 /* LinkedDot */, \".\" /* LinkedDot */);\r\n            case \":\" /* LinkedDelimiter */:\r\n                skipSpaces(scnr);\r\n                scnr.next();\r\n                return getToken(context, 10 /* LinkedDelimiter */, \":\" /* LinkedDelimiter */);\r\n            default:\r\n                if (isPluralStart(scnr)) {\r\n                    token = getToken(context, 1 /* Pipe */, readPlural(scnr));\r\n                    // reset\r\n                    context.braceNest = 0;\r\n                    context.inLinked = false;\r\n                    return token;\r\n                }\r\n                if (isLinkedDotStart(scnr, context) ||\r\n                    isLinkedDelimiterStart(scnr, context)) {\r\n                    skipSpaces(scnr);\r\n                    return readTokenInLinked(scnr, context);\r\n                }\r\n                if (isLinkedModifierStart(scnr, context)) {\r\n                    skipSpaces(scnr);\r\n                    return getToken(context, 12 /* LinkedModifier */, readLinkedModifier(scnr));\r\n                }\r\n                if (isLinkedReferStart(scnr, context)) {\r\n                    skipSpaces(scnr);\r\n                    if (ch === \"{\" /* BraceLeft */) {\r\n                        // scan the placeholder\r\n                        return readTokenInPlaceholder(scnr, context) || token;\r\n                    }\r\n                    else {\r\n                        return getToken(context, 11 /* LinkedKey */, readLinkedRefer(scnr));\r\n                    }\r\n                }\r\n                if (currentType === 8 /* LinkedAlias */) {\r\n                    emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);\r\n                }\r\n                context.braceNest = 0;\r\n                context.inLinked = false;\r\n                return readToken(scnr, context);\r\n        }\r\n    }\r\n    // TODO: We need refactoring of token parsing ...\r\n    function readToken(scnr, context) {\r\n        let token = { type: 14 /* EOF */ };\r\n        if (context.braceNest > 0) {\r\n            return readTokenInPlaceholder(scnr, context) || getEndToken(context);\r\n        }\r\n        if (context.inLinked) {\r\n            return readTokenInLinked(scnr, context) || getEndToken(context);\r\n        }\r\n        const ch = scnr.currentChar();\r\n        switch (ch) {\r\n            case \"{\" /* BraceLeft */:\r\n                return readTokenInPlaceholder(scnr, context) || getEndToken(context);\r\n            case \"}\" /* BraceRight */:\r\n                emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);\r\n                scnr.next();\r\n                return getToken(context, 3 /* BraceRight */, \"}\" /* BraceRight */);\r\n            case \"@\" /* LinkedAlias */:\r\n                return readTokenInLinked(scnr, context) || getEndToken(context);\r\n            default:\r\n                if (isPluralStart(scnr)) {\r\n                    token = getToken(context, 1 /* Pipe */, readPlural(scnr));\r\n                    // reset\r\n                    context.braceNest = 0;\r\n                    context.inLinked = false;\r\n                    return token;\r\n                }\r\n                if (isTextStart(scnr)) {\r\n                    return getToken(context, 0 /* Text */, readText(scnr));\r\n                }\r\n                if (ch === \"%\" /* Modulo */) {\r\n                    scnr.next();\r\n                    return getToken(context, 4 /* Modulo */, \"%\" /* Modulo */);\r\n                }\r\n                break;\r\n        }\r\n        return token;\r\n    }\r\n    function nextToken() {\r\n        const { currentType, offset, startLoc, endLoc } = _context;\r\n        _context.lastType = currentType;\r\n        _context.lastOffset = offset;\r\n        _context.lastStartLoc = startLoc;\r\n        _context.lastEndLoc = endLoc;\r\n        _context.offset = currentOffset();\r\n        _context.startLoc = currentPosition();\r\n        if (_scnr.currentChar() === EOF) {\r\n            return getToken(_context, 14 /* EOF */);\r\n        }\r\n        return readToken(_scnr, _context);\r\n    }\r\n    return {\r\n        nextToken,\r\n        currentOffset,\r\n        currentPosition,\r\n        context\r\n    };\r\n}\n\nconst ERROR_DOMAIN = 'parser';\r\n// Backslash backslash, backslash quote, uHHHH, UHHHHHH.\r\nconst KNOWN_ESCAPES = /(?:\\\\\\\\|\\\\'|\\\\u([0-9a-fA-F]{4})|\\\\U([0-9a-fA-F]{6}))/g;\r\nfunction fromEscapeSequence(match, codePoint4, codePoint6) {\r\n    switch (match) {\r\n        case `\\\\\\\\`:\r\n            return `\\\\`;\r\n        case `\\\\\\'`:\r\n            return `\\'`;\r\n        default: {\r\n            const codePoint = parseInt(codePoint4 || codePoint6, 16);\r\n            if (codePoint <= 0xd7ff || codePoint >= 0xe000) {\r\n                return String.fromCodePoint(codePoint);\r\n            }\r\n            // invalid ...\r\n            // Replace them with U+FFFD REPLACEMENT CHARACTER.\r\n            return '�';\r\n        }\r\n    }\r\n}\r\nfunction createParser(options = {}) {\r\n    const location = options.location !== false;\r\n    const { onError } = options;\r\n    function emitError(tokenzer, code, start, offset, ...args) {\r\n        const end = tokenzer.currentPosition();\r\n        end.offset += offset;\r\n        end.column += offset;\r\n        if (onError) {\r\n            const loc = createLocation(start, end);\r\n            const err = createCompileError(code, loc, {\r\n                domain: ERROR_DOMAIN,\r\n                args\r\n            });\r\n            onError(err);\r\n        }\r\n    }\r\n    function startNode(type, offset, loc) {\r\n        const node = {\r\n            type,\r\n            start: offset,\r\n            end: offset\r\n        };\r\n        if (location) {\r\n            node.loc = { start: loc, end: loc };\r\n        }\r\n        return node;\r\n    }\r\n    function endNode(node, offset, pos, type) {\r\n        node.end = offset;\r\n        if (type) {\r\n            node.type = type;\r\n        }\r\n        if (location && node.loc) {\r\n            node.loc.end = pos;\r\n        }\r\n    }\r\n    function parseText(tokenizer, value) {\r\n        const context = tokenizer.context();\r\n        const node = startNode(3 /* Text */, context.offset, context.startLoc);\r\n        node.value = value;\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    function parseList(tokenizer, index) {\r\n        const context = tokenizer.context();\r\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc\r\n        const node = startNode(5 /* List */, offset, loc);\r\n        node.index = parseInt(index, 10);\r\n        tokenizer.nextToken(); // skip brach right\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    function parseNamed(tokenizer, key) {\r\n        const context = tokenizer.context();\r\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc\r\n        const node = startNode(4 /* Named */, offset, loc);\r\n        node.key = key;\r\n        tokenizer.nextToken(); // skip brach right\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    function parseLiteral(tokenizer, value) {\r\n        const context = tokenizer.context();\r\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc\r\n        const node = startNode(9 /* Literal */, offset, loc);\r\n        node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);\r\n        tokenizer.nextToken(); // skip brach right\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    function parseLinkedModifier(tokenizer) {\r\n        const token = tokenizer.nextToken();\r\n        const context = tokenizer.context();\r\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get linked dot loc\r\n        const node = startNode(8 /* LinkedModifier */, offset, loc);\r\n        if (token.type !== 12 /* LinkedModifier */) {\r\n            // empty modifier\r\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);\r\n            node.value = '';\r\n            endNode(node, offset, loc);\r\n            return {\r\n                nextConsumeToken: token,\r\n                node\r\n            };\r\n        }\r\n        // check token\r\n        if (token.value == null) {\r\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n        }\r\n        node.value = token.value || '';\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return {\r\n            node\r\n        };\r\n    }\r\n    function parseLinkedKey(tokenizer, value) {\r\n        const context = tokenizer.context();\r\n        const node = startNode(7 /* LinkedKey */, context.offset, context.startLoc);\r\n        node.value = value;\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    function parseLinked(tokenizer) {\r\n        const context = tokenizer.context();\r\n        const linkedNode = startNode(6 /* Linked */, context.offset, context.startLoc);\r\n        let token = tokenizer.nextToken();\r\n        if (token.type === 9 /* LinkedDot */) {\r\n            const parsed = parseLinkedModifier(tokenizer);\r\n            linkedNode.modifier = parsed.node;\r\n            token = parsed.nextConsumeToken || tokenizer.nextToken();\r\n        }\r\n        // asset check token\r\n        if (token.type !== 10 /* LinkedDelimiter */) {\r\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n        }\r\n        token = tokenizer.nextToken();\r\n        // skip brace left\r\n        if (token.type === 2 /* BraceLeft */) {\r\n            token = tokenizer.nextToken();\r\n        }\r\n        switch (token.type) {\r\n            case 11 /* LinkedKey */:\r\n                if (token.value == null) {\r\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n                }\r\n                linkedNode.key = parseLinkedKey(tokenizer, token.value || '');\r\n                break;\r\n            case 5 /* Named */:\r\n                if (token.value == null) {\r\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n                }\r\n                linkedNode.key = parseNamed(tokenizer, token.value || '');\r\n                break;\r\n            case 6 /* List */:\r\n                if (token.value == null) {\r\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n                }\r\n                linkedNode.key = parseList(tokenizer, token.value || '');\r\n                break;\r\n            case 7 /* Literal */:\r\n                if (token.value == null) {\r\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n                }\r\n                linkedNode.key = parseLiteral(tokenizer, token.value || '');\r\n                break;\r\n            default:\r\n                // empty key\r\n                emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);\r\n                const nextContext = tokenizer.context();\r\n                const emptyLinkedKeyNode = startNode(7 /* LinkedKey */, nextContext.offset, nextContext.startLoc);\r\n                emptyLinkedKeyNode.value = '';\r\n                endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);\r\n                linkedNode.key = emptyLinkedKeyNode;\r\n                endNode(linkedNode, nextContext.offset, nextContext.startLoc);\r\n                return {\r\n                    nextConsumeToken: token,\r\n                    node: linkedNode\r\n                };\r\n        }\r\n        endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return {\r\n            node: linkedNode\r\n        };\r\n    }\r\n    function parseMessage(tokenizer) {\r\n        const context = tokenizer.context();\r\n        const startOffset = context.currentType === 1 /* Pipe */\r\n            ? tokenizer.currentOffset()\r\n            : context.offset;\r\n        const startLoc = context.currentType === 1 /* Pipe */\r\n            ? context.endLoc\r\n            : context.startLoc;\r\n        const node = startNode(2 /* Message */, startOffset, startLoc);\r\n        node.items = [];\r\n        let nextToken = null;\r\n        do {\r\n            const token = nextToken || tokenizer.nextToken();\r\n            nextToken = null;\r\n            switch (token.type) {\r\n                case 0 /* Text */:\r\n                    if (token.value == null) {\r\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n                    }\r\n                    node.items.push(parseText(tokenizer, token.value || ''));\r\n                    break;\r\n                case 6 /* List */:\r\n                    if (token.value == null) {\r\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n                    }\r\n                    node.items.push(parseList(tokenizer, token.value || ''));\r\n                    break;\r\n                case 5 /* Named */:\r\n                    if (token.value == null) {\r\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n                    }\r\n                    node.items.push(parseNamed(tokenizer, token.value || ''));\r\n                    break;\r\n                case 7 /* Literal */:\r\n                    if (token.value == null) {\r\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\r\n                    }\r\n                    node.items.push(parseLiteral(tokenizer, token.value || ''));\r\n                    break;\r\n                case 8 /* LinkedAlias */:\r\n                    const parsed = parseLinked(tokenizer);\r\n                    node.items.push(parsed.node);\r\n                    nextToken = parsed.nextConsumeToken || null;\r\n                    break;\r\n            }\r\n        } while (context.currentType !== 14 /* EOF */ &&\r\n            context.currentType !== 1 /* Pipe */);\r\n        // adjust message node loc\r\n        const endOffset = context.currentType === 1 /* Pipe */\r\n            ? context.lastOffset\r\n            : tokenizer.currentOffset();\r\n        const endLoc = context.currentType === 1 /* Pipe */\r\n            ? context.lastEndLoc\r\n            : tokenizer.currentPosition();\r\n        endNode(node, endOffset, endLoc);\r\n        return node;\r\n    }\r\n    function parsePlural(tokenizer, offset, loc, msgNode) {\r\n        const context = tokenizer.context();\r\n        let hasEmptyMessage = msgNode.items.length === 0;\r\n        const node = startNode(1 /* Plural */, offset, loc);\r\n        node.cases = [];\r\n        node.cases.push(msgNode);\r\n        do {\r\n            const msg = parseMessage(tokenizer);\r\n            if (!hasEmptyMessage) {\r\n                hasEmptyMessage = msg.items.length === 0;\r\n            }\r\n            node.cases.push(msg);\r\n        } while (context.currentType !== 14 /* EOF */);\r\n        if (hasEmptyMessage) {\r\n            emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);\r\n        }\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    function parseResource(tokenizer) {\r\n        const context = tokenizer.context();\r\n        const { offset, startLoc } = context;\r\n        const msgNode = parseMessage(tokenizer);\r\n        if (context.currentType === 14 /* EOF */) {\r\n            return msgNode;\r\n        }\r\n        else {\r\n            return parsePlural(tokenizer, offset, startLoc, msgNode);\r\n        }\r\n    }\r\n    function parse(source) {\r\n        const tokenizer = createTokenizer(source, assign({}, options));\r\n        const context = tokenizer.context();\r\n        const node = startNode(0 /* Resource */, context.offset, context.startLoc);\r\n        if (location && node.loc) {\r\n            node.loc.source = source;\r\n        }\r\n        node.body = parseResource(tokenizer);\r\n        // assert whether achieved to EOF\r\n        if (context.currentType !== 14 /* EOF */) {\r\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || '');\r\n        }\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    return { parse };\r\n}\r\nfunction getTokenCaption(token) {\r\n    if (token.type === 14 /* EOF */) {\r\n        return 'EOF';\r\n    }\r\n    const name = (token.value || '').replace(/\\r?\\n/gu, '\\\\n');\r\n    return name.length > 10 ? name.slice(0, 9) + '…' : name;\r\n}\n\nfunction createTransformer(ast, options = {} // eslint-disable-line\r\n) {\r\n    const _context = {\r\n        ast,\r\n        helpers: new Set()\r\n    };\r\n    const context = () => _context;\r\n    const helper = (name) => {\r\n        _context.helpers.add(name);\r\n        return name;\r\n    };\r\n    return { context, helper };\r\n}\r\nfunction traverseNodes(nodes, transformer) {\r\n    for (let i = 0; i < nodes.length; i++) {\r\n        traverseNode(nodes[i], transformer);\r\n    }\r\n}\r\nfunction traverseNode(node, transformer) {\r\n    // TODO: if we need pre-hook of transform, should be implemented to here\r\n    switch (node.type) {\r\n        case 1 /* Plural */:\r\n            traverseNodes(node.cases, transformer);\r\n            transformer.helper(\"plural\" /* PLURAL */);\r\n            break;\r\n        case 2 /* Message */:\r\n            traverseNodes(node.items, transformer);\r\n            break;\r\n        case 6 /* Linked */:\r\n            const linked = node;\r\n            traverseNode(linked.key, transformer);\r\n            transformer.helper(\"linked\" /* LINKED */);\r\n            break;\r\n        case 5 /* List */:\r\n            transformer.helper(\"interpolate\" /* INTERPOLATE */);\r\n            transformer.helper(\"list\" /* LIST */);\r\n            break;\r\n        case 4 /* Named */:\r\n            transformer.helper(\"interpolate\" /* INTERPOLATE */);\r\n            transformer.helper(\"named\" /* NAMED */);\r\n            break;\r\n    }\r\n    // TODO: if we need post-hook of transform, should be implemented to here\r\n}\r\n// transform AST\r\nfunction transform(ast, options = {} // eslint-disable-line\r\n) {\r\n    const transformer = createTransformer(ast);\r\n    transformer.helper(\"normalize\" /* NORMALIZE */);\r\n    // traverse\r\n    ast.body && traverseNode(ast.body, transformer);\r\n    // set meta information\r\n    const context = transformer.context();\r\n    ast.helpers = Array.from(context.helpers);\r\n}\n\nfunction createCodeGenerator(ast, options) {\r\n    const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options;\r\n    const _context = {\r\n        source: ast.loc.source,\r\n        filename,\r\n        code: '',\r\n        column: 1,\r\n        line: 1,\r\n        offset: 0,\r\n        map: undefined,\r\n        breakLineCode,\r\n        needIndent: _needIndent,\r\n        indentLevel: 0\r\n    };\r\n    const context = () => _context;\r\n    function push(code, node) {\r\n        _context.code += code;\r\n    }\r\n    function _newline(n, withBreakLine = true) {\r\n        const _breakLineCode = withBreakLine ? breakLineCode : '';\r\n        push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);\r\n    }\r\n    function indent(withNewLine = true) {\r\n        const level = ++_context.indentLevel;\r\n        withNewLine && _newline(level);\r\n    }\r\n    function deindent(withNewLine = true) {\r\n        const level = --_context.indentLevel;\r\n        withNewLine && _newline(level);\r\n    }\r\n    function newline() {\r\n        _newline(_context.indentLevel);\r\n    }\r\n    const helper = (key) => `_${key}`;\r\n    const needIndent = () => _context.needIndent;\r\n    return {\r\n        context,\r\n        push,\r\n        indent,\r\n        deindent,\r\n        newline,\r\n        helper,\r\n        needIndent\r\n    };\r\n}\r\nfunction generateLinkedNode(generator, node) {\r\n    const { helper } = generator;\r\n    generator.push(`${helper(\"linked\" /* LINKED */)}(`);\r\n    generateNode(generator, node.key);\r\n    if (node.modifier) {\r\n        generator.push(`, `);\r\n        generateNode(generator, node.modifier);\r\n    }\r\n    generator.push(`)`);\r\n}\r\nfunction generateMessageNode(generator, node) {\r\n    const { helper, needIndent } = generator;\r\n    generator.push(`${helper(\"normalize\" /* NORMALIZE */)}([`);\r\n    generator.indent(needIndent());\r\n    const length = node.items.length;\r\n    for (let i = 0; i < length; i++) {\r\n        generateNode(generator, node.items[i]);\r\n        if (i === length - 1) {\r\n            break;\r\n        }\r\n        generator.push(', ');\r\n    }\r\n    generator.deindent(needIndent());\r\n    generator.push('])');\r\n}\r\nfunction generatePluralNode(generator, node) {\r\n    const { helper, needIndent } = generator;\r\n    if (node.cases.length > 1) {\r\n        generator.push(`${helper(\"plural\" /* PLURAL */)}([`);\r\n        generator.indent(needIndent());\r\n        const length = node.cases.length;\r\n        for (let i = 0; i < length; i++) {\r\n            generateNode(generator, node.cases[i]);\r\n            if (i === length - 1) {\r\n                break;\r\n            }\r\n            generator.push(', ');\r\n        }\r\n        generator.deindent(needIndent());\r\n        generator.push(`])`);\r\n    }\r\n}\r\nfunction generateResource(generator, node) {\r\n    if (node.body) {\r\n        generateNode(generator, node.body);\r\n    }\r\n    else {\r\n        generator.push('null');\r\n    }\r\n}\r\nfunction generateNode(generator, node) {\r\n    const { helper } = generator;\r\n    switch (node.type) {\r\n        case 0 /* Resource */:\r\n            generateResource(generator, node);\r\n            break;\r\n        case 1 /* Plural */:\r\n            generatePluralNode(generator, node);\r\n            break;\r\n        case 2 /* Message */:\r\n            generateMessageNode(generator, node);\r\n            break;\r\n        case 6 /* Linked */:\r\n            generateLinkedNode(generator, node);\r\n            break;\r\n        case 8 /* LinkedModifier */:\r\n            generator.push(JSON.stringify(node.value), node);\r\n            break;\r\n        case 7 /* LinkedKey */:\r\n            generator.push(JSON.stringify(node.value), node);\r\n            break;\r\n        case 5 /* List */:\r\n            generator.push(`${helper(\"interpolate\" /* INTERPOLATE */)}(${helper(\"list\" /* LIST */)}(${node.index}))`, node);\r\n            break;\r\n        case 4 /* Named */:\r\n            generator.push(`${helper(\"interpolate\" /* INTERPOLATE */)}(${helper(\"named\" /* NAMED */)}(${JSON.stringify(node.key)}))`, node);\r\n            break;\r\n        case 9 /* Literal */:\r\n            generator.push(JSON.stringify(node.value), node);\r\n            break;\r\n        case 3 /* Text */:\r\n            generator.push(JSON.stringify(node.value), node);\r\n            break;\r\n        default:\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                throw new Error(`unhandled codegen node type: ${node.type}`);\r\n            }\r\n    }\r\n}\r\n// generate code from AST\r\nconst generate = (ast, options = {} // eslint-disable-line\r\n) => {\r\n    const mode = isString(options.mode) ? options.mode : 'normal';\r\n    const filename = isString(options.filename)\r\n        ? options.filename\r\n        : 'message.intl';\r\n    const sourceMap = !!options.sourceMap;\r\n    // prettier-ignore\r\n    const breakLineCode = options.breakLineCode != null\r\n        ? options.breakLineCode\r\n        : mode === 'arrow'\r\n            ? ';'\r\n            : '\\n';\r\n    const needIndent = options.needIndent ? options.needIndent : mode !== 'arrow';\r\n    const helpers = ast.helpers || [];\r\n    const generator = createCodeGenerator(ast, {\r\n        mode,\r\n        filename,\r\n        sourceMap,\r\n        breakLineCode,\r\n        needIndent\r\n    });\r\n    generator.push(mode === 'normal' ? `function __msg__ (ctx) {` : `(ctx) => {`);\r\n    generator.indent(needIndent);\r\n    if (helpers.length > 0) {\r\n        generator.push(`const { ${helpers.map(s => `${s}: _${s}`).join(', ')} } = ctx`);\r\n        generator.newline();\r\n    }\r\n    generator.push(`return `);\r\n    generateNode(generator, ast);\r\n    generator.deindent(needIndent);\r\n    generator.push(`}`);\r\n    const { code, map } = generator.context();\r\n    return {\r\n        ast,\r\n        code,\r\n        map: map ? map.toJSON() : undefined // eslint-disable-line @typescript-eslint/no-explicit-any\r\n    };\r\n};\n\nfunction baseCompile(source, options = {}) {\r\n    const assignedOptions = assign({}, options);\r\n    // parse source codes\r\n    const parser = createParser(assignedOptions);\r\n    const ast = parser.parse(source);\r\n    // transform ASTs\r\n    transform(ast, assignedOptions);\r\n    // generate javascript codes\r\n    return generate(ast, assignedOptions);\r\n}\n\nexport { CompileErrorCodes, ERROR_DOMAIN, LocationStub, baseCompile, createCompileError, createLocation, createParser, createPosition, defaultOnError, errorMessages };\n"]},"metadata":{},"sourceType":"module"}