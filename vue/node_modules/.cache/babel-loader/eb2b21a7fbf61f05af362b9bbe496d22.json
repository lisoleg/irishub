{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.typed-array.at.js\");\n\nrequire(\"core-js/modules/es.typed-array.set.js\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Link = exports.otherSide = void 0;\n\nconst utils_1 = require(\"@cosmjs/utils\");\n\nconst channel_1 = require(\"../codec/ibc/core/channel/v1/channel\");\n\nconst endpoint_1 = require(\"./endpoint\");\n\nconst ibcclient_1 = require(\"./ibcclient\");\n\nconst logger_1 = require(\"./logger\");\n\nconst utils_2 = require(\"./utils\");\n\nfunction otherSide(side) {\n  if (side === 'A') {\n    return 'B';\n  } else {\n    return 'A';\n  }\n}\n\nexports.otherSide = otherSide;\n/**\n * Link represents a Connection between a pair of blockchains (Nodes).\n * An initialized Link requires a both sides to have a Client for the remote side\n * as well as an established Connection using those Clients. Channels can be added\n * and removed to a Link. There are constructors to find/create the basic requirements\n * if you don't know the client/connection IDs a priori.\n */\n\nclass Link {\n  // you can use this if you already have the info out of bounds\n  // FIXME: check the validity of that data?\n  constructor(endA, endB, logger) {\n    this.endA = endA;\n    this.endB = endB;\n    this.logger = logger !== null && logger !== void 0 ? logger : new logger_1.NoopLogger();\n    this.chainA = endA.client.chainId;\n    this.chainB = endB.client.chainId;\n  }\n\n  chain(side) {\n    if (side === 'A') {\n      return this.chainA;\n    } else {\n      return this.chainB;\n    }\n  }\n\n  otherChain(side) {\n    if (side === 'A') {\n      return this.chainB;\n    } else {\n      return this.chainA;\n    }\n  }\n  /**\n   * findConnection attempts to reuse an existing Client/Connection.\n   * If none exists, then it returns an error.\n   *\n   * @param nodeA\n   * @param nodeB\n   */\n\n\n  static createWithExistingConnections(nodeA, nodeB, connA, connB, logger) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const [chainA, chainB] = [nodeA.chainId, nodeB.chainId];\n      const [{\n        connection: connectionA\n      }, {\n        connection: connectionB\n      }] = yield Promise.all([nodeA.query.ibc.connection.connection(connA), nodeB.query.ibc.connection.connection(connB)]);\n\n      if (!connectionA) {\n        throw new Error(`[${chainA}] Connection not found for ID ${connA}`);\n      }\n\n      if (!connectionB) {\n        throw new Error(`[${chainB}] Connection not found for ID ${connB}`);\n      }\n\n      if (!connectionA.counterparty) {\n        throw new Error(`[${chainA}] Counterparty not found for connection with ID ${connA}`);\n      }\n\n      if (!connectionB.counterparty) {\n        throw new Error(`[${chainB}] Counterparty not found for connection with ID ${connB}`);\n      } // ensure the connection is open\n\n\n      if (connectionA.state != channel_1.State.STATE_OPEN) {\n        throw new Error(`Connection on ${chainA} must be in state open, it has state ${connectionA.state}`);\n      }\n\n      if (connectionB.state != channel_1.State.STATE_OPEN) {\n        throw new Error(`Connection on ${chainB} must be in state open, it has state ${connectionB.state}`);\n      }\n\n      const [clientIdA, clientIdB] = [connectionA.clientId, connectionB.clientId];\n\n      if (clientIdA !== connectionB.counterparty.clientId) {\n        throw new Error(`Client ID ${connectionA.clientId} for connection with ID ${connA} does not match counterparty client ID ${connectionB.counterparty.clientId} for connection with ID ${connB}`);\n      }\n\n      if (clientIdB !== connectionA.counterparty.clientId) {\n        throw new Error(`Client ID ${connectionB.clientId} for connection with ID ${connB} does not match counterparty client ID ${connectionA.counterparty.clientId} for connection with ID ${connA}`);\n      }\n\n      const [clientStateA, clientStateB] = yield Promise.all([nodeA.query.ibc.client.stateTm(clientIdA), nodeB.query.ibc.client.stateTm(clientIdB)]);\n\n      if (nodeA.chainId !== clientStateB.chainId) {\n        throw new Error(`Chain ID ${nodeA.chainId} for connection with ID ${connA} does not match remote chain ID ${clientStateA.chainId}`);\n      }\n\n      if (nodeB.chainId !== clientStateA.chainId) {\n        throw new Error(`Chain ID ${nodeB.chainId} for connection with ID ${connB} does not match remote chain ID ${clientStateB.chainId}`);\n      }\n\n      const endA = new endpoint_1.Endpoint(nodeA, clientIdA, connA);\n      const endB = new endpoint_1.Endpoint(nodeB, clientIdB, connB);\n      const link = new Link(endA, endB, logger);\n      yield Promise.all([link.assertHeadersMatchConsensusState('A', clientIdA, clientStateA.latestHeight), link.assertHeadersMatchConsensusState('B', clientIdB, clientStateB.latestHeight)]);\n      return link;\n    });\n  }\n  /**\n   * we do this assert inside createWithExistingConnections, but it could be a useful check\n   * for submitting double-sign evidence later\n   *\n   * @param proofSide the side holding the consensus proof, we check the header from the other side\n   * @param height the height of the consensus state and header we wish to compare\n   */\n\n\n  assertHeadersMatchConsensusState(proofSide, clientId, height) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        src,\n        dest\n      } = this.getEnds(proofSide); // Check headers match consensus state (at least validators)\n\n      const [consensusState, header] = yield Promise.all([src.client.query.ibc.client.consensusStateTm(clientId, height), dest.client.header(utils_2.toIntHeight(height))]); // ensure consensus and headers match for next validator hashes\n\n      if (!utils_1.arrayContentEquals(consensusState.nextValidatorsHash, header.nextValidatorsHash)) {\n        throw new Error(`NextValidatorHash doesn't match ConsensusState.`);\n      } // ensure the committed apphash matches the actual node we have\n\n\n      const hash = (_a = consensusState.root) === null || _a === void 0 ? void 0 : _a.hash;\n\n      if (!hash) {\n        throw new Error(`ConsensusState.root.hash missing.`);\n      }\n\n      if (!utils_1.arrayContentEquals(hash, header.appHash)) {\n        throw new Error(`AppHash doesn't match ConsensusState.`);\n      }\n    });\n  }\n  /**\n   * createConnection will always create a new pair of clients and a Connection between the\n   * two sides\n   *\n   * @param nodeA\n   * @param nodeB\n   */\n\n\n  static createWithNewConnections(nodeA, nodeB, logger, // number of seconds the client (on B pointing to A) is valid without update\n  trustPeriodA, // number of seconds the client (on A pointing to B) is valid without update\n  trustPeriodB) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const [clientIdA, clientIdB] = yield createClients(nodeA, nodeB, trustPeriodA, trustPeriodB); // wait a block to ensure we have proper proofs for creating a connection (this has failed on CI before)\n\n      yield Promise.all([nodeA.waitOneBlock(), nodeB.waitOneBlock()]); // connectionInit on nodeA\n\n      const {\n        connectionId: connIdA\n      } = yield nodeA.connOpenInit(clientIdA, clientIdB); // connectionTry on nodeB\n\n      const proof = yield ibcclient_1.prepareConnectionHandshake(nodeA, nodeB, clientIdA, clientIdB, connIdA);\n      const {\n        connectionId: connIdB\n      } = yield nodeB.connOpenTry(clientIdB, proof); // connectionAck on nodeA\n\n      const proofAck = yield ibcclient_1.prepareConnectionHandshake(nodeB, nodeA, clientIdB, clientIdA, connIdB);\n      yield nodeA.connOpenAck(connIdA, proofAck); // connectionConfirm on dest\n\n      const proofConfirm = yield ibcclient_1.prepareConnectionHandshake(nodeA, nodeB, clientIdA, clientIdB, connIdA);\n      yield nodeB.connOpenConfirm(connIdB, proofConfirm);\n      const endA = new endpoint_1.Endpoint(nodeA, clientIdA, connIdA);\n      const endB = new endpoint_1.Endpoint(nodeB, clientIdB, connIdB);\n      return new Link(endA, endB, logger);\n    });\n  }\n  /**\n   * Writes the latest header from the sender chain to the other endpoint\n   *\n   * @param sender Which side we get the header/commit from\n   * @returns header height (from sender) that is now known on dest\n   *\n   * Relayer binary should call this from a heartbeat which checks if needed and updates.\n   * Just needs trusting period on both side\n   */\n\n\n  updateClient(sender) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.logger.info(`Update Client on ${this.otherChain(sender)}`);\n      const {\n        src,\n        dest\n      } = this.getEnds(sender);\n      const height = yield dest.client.doUpdateClient(dest.clientID, src.client);\n      return height;\n    });\n  }\n  /**\n   * Checks if the last proven header on the destination is older than maxAge,\n   * and if so, update the client. Returns the new client height if updated,\n   * or null if no update needed\n   *\n   * @param sender\n   * @param maxAge\n   */\n\n\n  updateClientIfStale(sender, maxAge) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      this.logger.verbose(`Checking if ${this.otherChain(sender)} has recent header of ${this.chain(sender)}`);\n      const {\n        src,\n        dest\n      } = this.getEnds(sender);\n      const knownHeader = yield dest.client.query.ibc.client.consensusStateTm(dest.clientID);\n      const currentHeader = yield src.client.latestHeader(); // quit now if we don't need to update\n\n      const knownSeconds = (_b = (_a = knownHeader.timestamp) === null || _a === void 0 ? void 0 : _a.seconds) === null || _b === void 0 ? void 0 : _b.toNumber();\n\n      if (knownSeconds) {\n        const curSeconds = utils_2.timestampFromDateNanos(currentHeader.time).seconds.toNumber();\n\n        if (curSeconds - knownSeconds < maxAge) {\n          return null;\n        }\n      } // otherwise, do the update\n\n\n      return this.updateClient(sender);\n    });\n  }\n  /**\n   * Ensures the dest has a proof of at least minHeight from source.\n   * Will not execute any tx if not needed.\n   * Will wait a block if needed until the header is available.\n   *\n   * Returns the latest header height now available on dest\n   */\n\n\n  updateClientToHeight(source, minHeight) {\n    var _a, _b, _c;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      this.logger.info(`Check whether client on ${this.otherChain(source)} >= height ${minHeight}`);\n      const {\n        src,\n        dest\n      } = this.getEnds(source);\n      const client = yield dest.client.query.ibc.client.stateTm(dest.clientID); // TODO: revisit where revision number comes from - this must be the number from the source chain\n\n      const knownHeight = (_c = (_b = (_a = client.latestHeight) === null || _a === void 0 ? void 0 : _a.revisionHeight) === null || _b === void 0 ? void 0 : _b.toNumber()) !== null && _c !== void 0 ? _c : 0;\n\n      if (knownHeight >= minHeight && client.latestHeight !== undefined) {\n        return client.latestHeight;\n      }\n\n      const curHeight = (yield src.client.latestHeader()).height;\n\n      if (curHeight < minHeight) {\n        yield src.client.waitOneBlock();\n      }\n\n      return this.updateClient(source);\n    });\n  }\n\n  createChannel(sender, srcPort, destPort, ordering, version) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.logger.info(`Create channel with sender ${this.chain(sender)}: ${srcPort} => ${destPort}`);\n      const {\n        src,\n        dest\n      } = this.getEnds(sender); // init on src\n\n      const {\n        channelId: channelIdSrc\n      } = yield src.client.channelOpenInit(srcPort, destPort, ordering, src.connectionID, version); // try on dest\n\n      const proof = yield ibcclient_1.prepareChannelHandshake(src.client, dest.client, dest.clientID, srcPort, channelIdSrc);\n      const {\n        channelId: channelIdDest\n      } = yield dest.client.channelOpenTry(destPort, {\n        portId: srcPort,\n        channelId: channelIdSrc\n      }, ordering, dest.connectionID, version, version, proof); // ack on src\n\n      const proofAck = yield ibcclient_1.prepareChannelHandshake(dest.client, src.client, src.clientID, destPort, channelIdDest);\n      yield src.client.channelOpenAck(srcPort, channelIdSrc, channelIdDest, version, proofAck); // confirm on dest\n\n      const proofConfirm = yield ibcclient_1.prepareChannelHandshake(src.client, dest.client, dest.clientID, srcPort, channelIdSrc);\n      yield dest.client.channelOpenConfirm(destPort, channelIdDest, proofConfirm);\n      return {\n        src: {\n          portId: srcPort,\n          channelId: channelIdSrc\n        },\n        dest: {\n          portId: destPort,\n          channelId: channelIdDest\n        }\n      };\n    });\n  }\n  /**\n   * This will check both sides for pending packets and relay them.\n   * It will then relay all acks (previous and generated by the just-submitted packets).\n   * If pending packets have timed out, it will submit a timeout instead of attempting to relay them.\n   *\n   * Returns the most recent heights it relay, which can be used as a start for the next round\n   */\n\n\n  checkAndRelayPacketsAndAcks(relayFrom, timedoutThresholdBlocks = 0, timedoutThresholdSeconds = 0) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // FIXME: is there a cleaner way to get the height we query at?\n      const [packetHeightA, packetHeightB, packetsA, packetsB] = yield Promise.all([this.endA.client.currentHeight(), this.endB.client.currentHeight(), this.getPendingPackets('A', {\n        minHeight: relayFrom.packetHeightA\n      }), this.getPendingPackets('B', {\n        minHeight: relayFrom.packetHeightB\n      })]);\n      const cutoffHeightA = yield this.endB.client.timeoutHeight(timedoutThresholdBlocks);\n      const cutoffTimeA = utils_2.secondsFromDateNanos(yield this.endB.client.currentTime()) + timedoutThresholdSeconds;\n      const {\n        toSubmit: submitA,\n        toTimeout: timeoutA\n      } = utils_2.splitPendingPackets(cutoffHeightA, cutoffTimeA, packetsA);\n      const cutoffHeightB = yield this.endA.client.timeoutHeight(timedoutThresholdBlocks);\n      const cutoffTimeB = utils_2.secondsFromDateNanos(yield this.endA.client.currentTime()) + timedoutThresholdSeconds;\n      const {\n        toSubmit: submitB,\n        toTimeout: timeoutB\n      } = utils_2.splitPendingPackets(cutoffHeightB, cutoffTimeB, packetsB); // FIXME: use the returned acks first? Then query for others?\n\n      yield Promise.all([this.relayPackets('A', submitA), this.relayPackets('B', submitB)]); // let's wait a bit to ensure our newly committed acks are indexed\n\n      yield Promise.all([this.endA.client.waitOneBlock(), this.endB.client.waitOneBlock()]);\n      const [ackHeightA, ackHeightB, acksA, acksB] = yield Promise.all([this.endA.client.currentHeight(), this.endB.client.currentHeight(), this.getPendingAcks('A', {\n        minHeight: relayFrom.ackHeightA\n      }), this.getPendingAcks('B', {\n        minHeight: relayFrom.ackHeightB\n      })]);\n      yield Promise.all([this.relayAcks('A', acksA), this.relayAcks('B', acksB)]);\n      yield Promise.all([this.timeoutPackets('A', timeoutA), this.timeoutPackets('B', timeoutB)]);\n      const nextRelay = {\n        packetHeightA,\n        packetHeightB,\n        ackHeightA,\n        ackHeightB\n      };\n      this.logger.verbose('next heights to relay', nextRelay);\n      return nextRelay;\n    });\n  }\n\n  getPendingPackets(source, opts = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.logger.verbose(`Get pending packets on ${this.chain(source)}`);\n      const {\n        src,\n        dest\n      } = this.getEnds(source);\n      const allPackets = yield src.querySentPackets(opts);\n      const toFilter = allPackets.map(({\n        packet\n      }) => packet);\n\n      const query = (port, channel, sequences) => __awaiter(this, void 0, void 0, function* () {\n        const res = yield dest.client.query.ibc.channel.unreceivedPackets(port, channel, sequences);\n        return res.sequences.map(seq => seq.toNumber());\n      }); // This gets the subset of packets that were already processed on the receiving chain\n\n\n      const unreceived = yield this.filterUnreceived(toFilter, query, packetId);\n      const unreceivedPackets = allPackets.filter(({\n        packet\n      }) => unreceived[packetId(packet)].has(packet.sequence.toNumber())); // However, some of these may have already been submitted as timeouts on the source chain. Check and filter\n\n      const valid = yield Promise.all(unreceivedPackets.map(packet => __awaiter(this, void 0, void 0, function* () {\n        const {\n          sourcePort,\n          sourceChannel,\n          sequence\n        } = packet.packet;\n\n        try {\n          // this throws an error if no commitment there\n          yield src.client.query.ibc.channel.packetCommitment(sourcePort, sourceChannel, sequence);\n          return packet;\n        } catch (_a) {\n          return undefined;\n        }\n      })));\n      return valid.filter(x => x !== undefined);\n    });\n  }\n\n  getPendingAcks(source, opts = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.logger.verbose(`Get pending acks on ${this.chain(source)}`);\n      const {\n        src,\n        dest\n      } = this.getEnds(source);\n      const allAcks = yield src.queryWrittenAcks(opts);\n      const toFilter = allAcks.map(({\n        originalPacket\n      }) => originalPacket);\n\n      const query = (port, channel, sequences) => __awaiter(this, void 0, void 0, function* () {\n        const res = yield dest.client.query.ibc.channel.unreceivedAcks(port, channel, sequences);\n        return res.sequences.map(seq => seq.toNumber());\n      });\n\n      const unreceived = yield this.filterUnreceived(toFilter, query, ackId);\n      return allAcks.filter(({\n        originalPacket: packet\n      }) => unreceived[ackId(packet)].has(packet.sequence.toNumber()));\n    });\n  }\n\n  filterUnreceived(packets, unreceivedQuery, idFunc) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (packets.length === 0) {\n        return {};\n      }\n\n      const packetsPerDestination = packets.reduce((sorted, packet) => {\n        var _a;\n\n        const key = idFunc(packet);\n        return Object.assign(Object.assign({}, sorted), {\n          [key]: [...((_a = sorted[key]) !== null && _a !== void 0 ? _a : []), packet.sequence.toNumber()]\n        });\n      }, {});\n      const unreceivedResponses = yield Promise.all(Object.entries(packetsPerDestination).map(([destination, sequences]) => __awaiter(this, void 0, void 0, function* () {\n        const [port, channel] = destination.split(idDelim);\n        const notfound = yield unreceivedQuery(port, channel, sequences);\n        return {\n          key: destination,\n          sequences: notfound\n        };\n      })));\n      const unreceived = unreceivedResponses.reduce((nested, {\n        key,\n        sequences\n      }) => {\n        return Object.assign(Object.assign({}, nested), {\n          [key]: new Set(sequences)\n        });\n      }, {});\n      return unreceived;\n    });\n  } // Returns the last height that this side knows of the other blockchain\n\n\n  lastKnownHeader(side) {\n    var _a, _b, _c;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      this.logger.verbose(`Get last known header on ${this.chain(side)}`);\n      const {\n        src\n      } = this.getEnds(side);\n      const client = yield src.client.query.ibc.client.stateTm(src.clientID);\n      return (_c = (_b = (_a = client.latestHeight) === null || _a === void 0 ? void 0 : _a.revisionHeight) === null || _b === void 0 ? void 0 : _b.toNumber()) !== null && _c !== void 0 ? _c : 0;\n    });\n  } // this will update the client if needed and relay all provided packets from src -> dest\n  // if packets are all older than the last consensusHeight, then we don't update the client.\n  //\n  // Returns all the acks that are associated with the just submitted packets\n\n\n  relayPackets(source, packets) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.logger.info(`Relay ${packets.length} packets from ${this.chain(source)} => ${this.otherChain(source)}`);\n\n      if (packets.length === 0) {\n        return [];\n      }\n\n      const {\n        src,\n        dest\n      } = this.getEnds(source); // check if we need to update client at all\n\n      const neededHeight = Math.max(...packets.map(x => x.height)) + 1;\n      const headerHeight = yield this.updateClientToHeight(source, neededHeight);\n      const submit = packets.map(({\n        packet\n      }) => packet);\n      const proofs = yield Promise.all(submit.map(packet => src.client.getPacketProof(packet, headerHeight)));\n      const {\n        logs,\n        height\n      } = yield dest.client.receivePackets(submit, proofs, headerHeight);\n      const acks = utils_2.parseAcksFromLogs(logs);\n      return acks.map(ack => Object.assign({\n        height\n      }, ack));\n    });\n  } // this will update the client if needed and relay all provided acks from src -> dest\n  // (yes, dest is where the packet was sent, but the ack was written on src).\n  // if acks are all older than the last consensusHeight, then we don't update the client.\n  //\n  // Returns the block height the acks were included in, or null if no acks sent\n\n\n  relayAcks(source, acks) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.logger.info(`Relay ${acks.length} acks from ${this.chain(source)} => ${this.otherChain(source)}`);\n\n      if (acks.length === 0) {\n        return null;\n      }\n\n      const {\n        src,\n        dest\n      } = this.getEnds(source); // check if we need to update client at all\n\n      const neededHeight = Math.max(...acks.map(x => x.height)) + 1;\n      const headerHeight = yield this.updateClientToHeight(source, neededHeight);\n      const proofs = yield Promise.all(acks.map(ack => src.client.getAckProof(ack, headerHeight)));\n      const {\n        height\n      } = yield dest.client.acknowledgePackets(acks, proofs, headerHeight);\n      return height;\n    });\n  } // Source: the side that originally sent the packet\n  // We need to relay a proof from dest -> source\n\n\n  timeoutPackets(source, packets) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.logger.info(`Timeout ${packets.length} packets sent from ${this.chain(source)}`);\n\n      if (packets.length === 0) {\n        return null;\n      }\n\n      const {\n        src,\n        dest\n      } = this.getEnds(source);\n      const destSide = otherSide(source); // We need a header that is after the timeout, not after the packet was committed\n      // This can get complex with timeout timestamps. Let's just update to latest\n\n      yield dest.client.waitOneBlock();\n      const headerHeight = yield this.updateClient(destSide);\n      const rawPackets = packets.map(({\n        packet\n      }) => packet);\n      const proofAndSeqs = yield Promise.all(rawPackets.map(packet => __awaiter(this, void 0, void 0, function* () {\n        const fakeAck = {\n          originalPacket: packet,\n          acknowledgement: new Uint8Array()\n        };\n        const {\n          nextSequenceReceive: sequence\n        } = yield dest.client.query.ibc.channel.nextSequenceReceive(packet.destinationPort, packet.destinationChannel);\n        const proof = yield dest.client.getTimeoutProof(fakeAck, headerHeight);\n        return {\n          proof,\n          sequence\n        };\n      })));\n      const proofs = proofAndSeqs.map(({\n        proof\n      }) => proof);\n      const seqs = proofAndSeqs.map(({\n        sequence\n      }) => sequence);\n      const {\n        height\n      } = yield src.client.timeoutPackets(rawPackets, proofs, seqs, headerHeight);\n      return height;\n    });\n  }\n\n  getEnds(src) {\n    if (src === 'A') {\n      return {\n        src: this.endA,\n        dest: this.endB\n      };\n    } else {\n      return {\n        src: this.endB,\n        dest: this.endA\n      };\n    }\n  }\n\n}\n\nexports.Link = Link;\nconst idDelim = ':';\n\nconst packetId = packet => `${packet.destinationPort}${idDelim}${packet.destinationChannel}`;\n\nconst ackId = packet => `${packet.sourcePort}${idDelim}${packet.sourceChannel}`;\n\nfunction createClients(nodeA, nodeB, // number of seconds the client (on B pointing to A) is valid without update\ntrustPeriodA, // number of seconds the client (on A pointing to B) is valid without update\ntrustPeriodB) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // client on B pointing to A\n    const args = yield ibcclient_1.buildCreateClientArgs(nodeA, trustPeriodA);\n    const {\n      clientId: clientIdB\n    } = yield nodeB.createTendermintClient(args.clientState, args.consensusState); // client on A pointing to B\n\n    const args2 = yield ibcclient_1.buildCreateClientArgs(nodeB, trustPeriodB);\n    const {\n      clientId: clientIdA\n    } = yield nodeA.createTendermintClient(args2.clientState, args2.consensusState);\n    return [clientIdA, clientIdB];\n  });\n}","map":{"version":3,"sources":["../../src/lib/link.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Link = exports.otherSide = void 0;\nconst utils_1 = require(\"@cosmjs/utils\");\nconst channel_1 = require(\"../codec/ibc/core/channel/v1/channel\");\nconst endpoint_1 = require(\"./endpoint\");\nconst ibcclient_1 = require(\"./ibcclient\");\nconst logger_1 = require(\"./logger\");\nconst utils_2 = require(\"./utils\");\nfunction otherSide(side) {\n    if (side === 'A') {\n        return 'B';\n    }\n    else {\n        return 'A';\n    }\n}\nexports.otherSide = otherSide;\n/**\n * Link represents a Connection between a pair of blockchains (Nodes).\n * An initialized Link requires a both sides to have a Client for the remote side\n * as well as an established Connection using those Clients. Channels can be added\n * and removed to a Link. There are constructors to find/create the basic requirements\n * if you don't know the client/connection IDs a priori.\n */\nclass Link {\n    // you can use this if you already have the info out of bounds\n    // FIXME: check the validity of that data?\n    constructor(endA, endB, logger) {\n        this.endA = endA;\n        this.endB = endB;\n        this.logger = logger !== null && logger !== void 0 ? logger : new logger_1.NoopLogger();\n        this.chainA = endA.client.chainId;\n        this.chainB = endB.client.chainId;\n    }\n    chain(side) {\n        if (side === 'A') {\n            return this.chainA;\n        }\n        else {\n            return this.chainB;\n        }\n    }\n    otherChain(side) {\n        if (side === 'A') {\n            return this.chainB;\n        }\n        else {\n            return this.chainA;\n        }\n    }\n    /**\n     * findConnection attempts to reuse an existing Client/Connection.\n     * If none exists, then it returns an error.\n     *\n     * @param nodeA\n     * @param nodeB\n     */\n    static createWithExistingConnections(nodeA, nodeB, connA, connB, logger) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const [chainA, chainB] = [nodeA.chainId, nodeB.chainId];\n            const [{ connection: connectionA }, { connection: connectionB }] = yield Promise.all([\n                nodeA.query.ibc.connection.connection(connA),\n                nodeB.query.ibc.connection.connection(connB),\n            ]);\n            if (!connectionA) {\n                throw new Error(`[${chainA}] Connection not found for ID ${connA}`);\n            }\n            if (!connectionB) {\n                throw new Error(`[${chainB}] Connection not found for ID ${connB}`);\n            }\n            if (!connectionA.counterparty) {\n                throw new Error(`[${chainA}] Counterparty not found for connection with ID ${connA}`);\n            }\n            if (!connectionB.counterparty) {\n                throw new Error(`[${chainB}] Counterparty not found for connection with ID ${connB}`);\n            }\n            // ensure the connection is open\n            if (connectionA.state != channel_1.State.STATE_OPEN) {\n                throw new Error(`Connection on ${chainA} must be in state open, it has state ${connectionA.state}`);\n            }\n            if (connectionB.state != channel_1.State.STATE_OPEN) {\n                throw new Error(`Connection on ${chainB} must be in state open, it has state ${connectionB.state}`);\n            }\n            const [clientIdA, clientIdB] = [connectionA.clientId, connectionB.clientId];\n            if (clientIdA !== connectionB.counterparty.clientId) {\n                throw new Error(`Client ID ${connectionA.clientId} for connection with ID ${connA} does not match counterparty client ID ${connectionB.counterparty.clientId} for connection with ID ${connB}`);\n            }\n            if (clientIdB !== connectionA.counterparty.clientId) {\n                throw new Error(`Client ID ${connectionB.clientId} for connection with ID ${connB} does not match counterparty client ID ${connectionA.counterparty.clientId} for connection with ID ${connA}`);\n            }\n            const [clientStateA, clientStateB] = yield Promise.all([\n                nodeA.query.ibc.client.stateTm(clientIdA),\n                nodeB.query.ibc.client.stateTm(clientIdB),\n            ]);\n            if (nodeA.chainId !== clientStateB.chainId) {\n                throw new Error(`Chain ID ${nodeA.chainId} for connection with ID ${connA} does not match remote chain ID ${clientStateA.chainId}`);\n            }\n            if (nodeB.chainId !== clientStateA.chainId) {\n                throw new Error(`Chain ID ${nodeB.chainId} for connection with ID ${connB} does not match remote chain ID ${clientStateB.chainId}`);\n            }\n            const endA = new endpoint_1.Endpoint(nodeA, clientIdA, connA);\n            const endB = new endpoint_1.Endpoint(nodeB, clientIdB, connB);\n            const link = new Link(endA, endB, logger);\n            yield Promise.all([\n                link.assertHeadersMatchConsensusState('A', clientIdA, clientStateA.latestHeight),\n                link.assertHeadersMatchConsensusState('B', clientIdB, clientStateB.latestHeight),\n            ]);\n            return link;\n        });\n    }\n    /**\n     * we do this assert inside createWithExistingConnections, but it could be a useful check\n     * for submitting double-sign evidence later\n     *\n     * @param proofSide the side holding the consensus proof, we check the header from the other side\n     * @param height the height of the consensus state and header we wish to compare\n     */\n    assertHeadersMatchConsensusState(proofSide, clientId, height) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const { src, dest } = this.getEnds(proofSide);\n            // Check headers match consensus state (at least validators)\n            const [consensusState, header] = yield Promise.all([\n                src.client.query.ibc.client.consensusStateTm(clientId, height),\n                dest.client.header(utils_2.toIntHeight(height)),\n            ]);\n            // ensure consensus and headers match for next validator hashes\n            if (!utils_1.arrayContentEquals(consensusState.nextValidatorsHash, header.nextValidatorsHash)) {\n                throw new Error(`NextValidatorHash doesn't match ConsensusState.`);\n            }\n            // ensure the committed apphash matches the actual node we have\n            const hash = (_a = consensusState.root) === null || _a === void 0 ? void 0 : _a.hash;\n            if (!hash) {\n                throw new Error(`ConsensusState.root.hash missing.`);\n            }\n            if (!utils_1.arrayContentEquals(hash, header.appHash)) {\n                throw new Error(`AppHash doesn't match ConsensusState.`);\n            }\n        });\n    }\n    /**\n     * createConnection will always create a new pair of clients and a Connection between the\n     * two sides\n     *\n     * @param nodeA\n     * @param nodeB\n     */\n    static createWithNewConnections(nodeA, nodeB, logger, \n    // number of seconds the client (on B pointing to A) is valid without update\n    trustPeriodA, \n    // number of seconds the client (on A pointing to B) is valid without update\n    trustPeriodB) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const [clientIdA, clientIdB] = yield createClients(nodeA, nodeB, trustPeriodA, trustPeriodB);\n            // wait a block to ensure we have proper proofs for creating a connection (this has failed on CI before)\n            yield Promise.all([nodeA.waitOneBlock(), nodeB.waitOneBlock()]);\n            // connectionInit on nodeA\n            const { connectionId: connIdA } = yield nodeA.connOpenInit(clientIdA, clientIdB);\n            // connectionTry on nodeB\n            const proof = yield ibcclient_1.prepareConnectionHandshake(nodeA, nodeB, clientIdA, clientIdB, connIdA);\n            const { connectionId: connIdB } = yield nodeB.connOpenTry(clientIdB, proof);\n            // connectionAck on nodeA\n            const proofAck = yield ibcclient_1.prepareConnectionHandshake(nodeB, nodeA, clientIdB, clientIdA, connIdB);\n            yield nodeA.connOpenAck(connIdA, proofAck);\n            // connectionConfirm on dest\n            const proofConfirm = yield ibcclient_1.prepareConnectionHandshake(nodeA, nodeB, clientIdA, clientIdB, connIdA);\n            yield nodeB.connOpenConfirm(connIdB, proofConfirm);\n            const endA = new endpoint_1.Endpoint(nodeA, clientIdA, connIdA);\n            const endB = new endpoint_1.Endpoint(nodeB, clientIdB, connIdB);\n            return new Link(endA, endB, logger);\n        });\n    }\n    /**\n     * Writes the latest header from the sender chain to the other endpoint\n     *\n     * @param sender Which side we get the header/commit from\n     * @returns header height (from sender) that is now known on dest\n     *\n     * Relayer binary should call this from a heartbeat which checks if needed and updates.\n     * Just needs trusting period on both side\n     */\n    updateClient(sender) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.logger.info(`Update Client on ${this.otherChain(sender)}`);\n            const { src, dest } = this.getEnds(sender);\n            const height = yield dest.client.doUpdateClient(dest.clientID, src.client);\n            return height;\n        });\n    }\n    /**\n     * Checks if the last proven header on the destination is older than maxAge,\n     * and if so, update the client. Returns the new client height if updated,\n     * or null if no update needed\n     *\n     * @param sender\n     * @param maxAge\n     */\n    updateClientIfStale(sender, maxAge) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            this.logger.verbose(`Checking if ${this.otherChain(sender)} has recent header of ${this.chain(sender)}`);\n            const { src, dest } = this.getEnds(sender);\n            const knownHeader = yield dest.client.query.ibc.client.consensusStateTm(dest.clientID);\n            const currentHeader = yield src.client.latestHeader();\n            // quit now if we don't need to update\n            const knownSeconds = (_b = (_a = knownHeader.timestamp) === null || _a === void 0 ? void 0 : _a.seconds) === null || _b === void 0 ? void 0 : _b.toNumber();\n            if (knownSeconds) {\n                const curSeconds = utils_2.timestampFromDateNanos(currentHeader.time).seconds.toNumber();\n                if (curSeconds - knownSeconds < maxAge) {\n                    return null;\n                }\n            }\n            // otherwise, do the update\n            return this.updateClient(sender);\n        });\n    }\n    /**\n     * Ensures the dest has a proof of at least minHeight from source.\n     * Will not execute any tx if not needed.\n     * Will wait a block if needed until the header is available.\n     *\n     * Returns the latest header height now available on dest\n     */\n    updateClientToHeight(source, minHeight) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function* () {\n            this.logger.info(`Check whether client on ${this.otherChain(source)} >= height ${minHeight}`);\n            const { src, dest } = this.getEnds(source);\n            const client = yield dest.client.query.ibc.client.stateTm(dest.clientID);\n            // TODO: revisit where revision number comes from - this must be the number from the source chain\n            const knownHeight = (_c = (_b = (_a = client.latestHeight) === null || _a === void 0 ? void 0 : _a.revisionHeight) === null || _b === void 0 ? void 0 : _b.toNumber()) !== null && _c !== void 0 ? _c : 0;\n            if (knownHeight >= minHeight && client.latestHeight !== undefined) {\n                return client.latestHeight;\n            }\n            const curHeight = (yield src.client.latestHeader()).height;\n            if (curHeight < minHeight) {\n                yield src.client.waitOneBlock();\n            }\n            return this.updateClient(source);\n        });\n    }\n    createChannel(sender, srcPort, destPort, ordering, version) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.logger.info(`Create channel with sender ${this.chain(sender)}: ${srcPort} => ${destPort}`);\n            const { src, dest } = this.getEnds(sender);\n            // init on src\n            const { channelId: channelIdSrc } = yield src.client.channelOpenInit(srcPort, destPort, ordering, src.connectionID, version);\n            // try on dest\n            const proof = yield ibcclient_1.prepareChannelHandshake(src.client, dest.client, dest.clientID, srcPort, channelIdSrc);\n            const { channelId: channelIdDest } = yield dest.client.channelOpenTry(destPort, { portId: srcPort, channelId: channelIdSrc }, ordering, dest.connectionID, version, version, proof);\n            // ack on src\n            const proofAck = yield ibcclient_1.prepareChannelHandshake(dest.client, src.client, src.clientID, destPort, channelIdDest);\n            yield src.client.channelOpenAck(srcPort, channelIdSrc, channelIdDest, version, proofAck);\n            // confirm on dest\n            const proofConfirm = yield ibcclient_1.prepareChannelHandshake(src.client, dest.client, dest.clientID, srcPort, channelIdSrc);\n            yield dest.client.channelOpenConfirm(destPort, channelIdDest, proofConfirm);\n            return {\n                src: {\n                    portId: srcPort,\n                    channelId: channelIdSrc,\n                },\n                dest: {\n                    portId: destPort,\n                    channelId: channelIdDest,\n                },\n            };\n        });\n    }\n    /**\n     * This will check both sides for pending packets and relay them.\n     * It will then relay all acks (previous and generated by the just-submitted packets).\n     * If pending packets have timed out, it will submit a timeout instead of attempting to relay them.\n     *\n     * Returns the most recent heights it relay, which can be used as a start for the next round\n     */\n    checkAndRelayPacketsAndAcks(relayFrom, timedoutThresholdBlocks = 0, timedoutThresholdSeconds = 0) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // FIXME: is there a cleaner way to get the height we query at?\n            const [packetHeightA, packetHeightB, packetsA, packetsB] = yield Promise.all([\n                this.endA.client.currentHeight(),\n                this.endB.client.currentHeight(),\n                this.getPendingPackets('A', { minHeight: relayFrom.packetHeightA }),\n                this.getPendingPackets('B', { minHeight: relayFrom.packetHeightB }),\n            ]);\n            const cutoffHeightA = yield this.endB.client.timeoutHeight(timedoutThresholdBlocks);\n            const cutoffTimeA = utils_2.secondsFromDateNanos(yield this.endB.client.currentTime()) +\n                timedoutThresholdSeconds;\n            const { toSubmit: submitA, toTimeout: timeoutA } = utils_2.splitPendingPackets(cutoffHeightA, cutoffTimeA, packetsA);\n            const cutoffHeightB = yield this.endA.client.timeoutHeight(timedoutThresholdBlocks);\n            const cutoffTimeB = utils_2.secondsFromDateNanos(yield this.endA.client.currentTime()) +\n                timedoutThresholdSeconds;\n            const { toSubmit: submitB, toTimeout: timeoutB } = utils_2.splitPendingPackets(cutoffHeightB, cutoffTimeB, packetsB);\n            // FIXME: use the returned acks first? Then query for others?\n            yield Promise.all([\n                this.relayPackets('A', submitA),\n                this.relayPackets('B', submitB),\n            ]);\n            // let's wait a bit to ensure our newly committed acks are indexed\n            yield Promise.all([\n                this.endA.client.waitOneBlock(),\n                this.endB.client.waitOneBlock(),\n            ]);\n            const [ackHeightA, ackHeightB, acksA, acksB] = yield Promise.all([\n                this.endA.client.currentHeight(),\n                this.endB.client.currentHeight(),\n                this.getPendingAcks('A', { minHeight: relayFrom.ackHeightA }),\n                this.getPendingAcks('B', { minHeight: relayFrom.ackHeightB }),\n            ]);\n            yield Promise.all([this.relayAcks('A', acksA), this.relayAcks('B', acksB)]);\n            yield Promise.all([\n                this.timeoutPackets('A', timeoutA),\n                this.timeoutPackets('B', timeoutB),\n            ]);\n            const nextRelay = {\n                packetHeightA,\n                packetHeightB,\n                ackHeightA,\n                ackHeightB,\n            };\n            this.logger.verbose('next heights to relay', nextRelay);\n            return nextRelay;\n        });\n    }\n    getPendingPackets(source, opts = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.logger.verbose(`Get pending packets on ${this.chain(source)}`);\n            const { src, dest } = this.getEnds(source);\n            const allPackets = yield src.querySentPackets(opts);\n            const toFilter = allPackets.map(({ packet }) => packet);\n            const query = (port, channel, sequences) => __awaiter(this, void 0, void 0, function* () {\n                const res = yield dest.client.query.ibc.channel.unreceivedPackets(port, channel, sequences);\n                return res.sequences.map((seq) => seq.toNumber());\n            });\n            // This gets the subset of packets that were already processed on the receiving chain\n            const unreceived = yield this.filterUnreceived(toFilter, query, packetId);\n            const unreceivedPackets = allPackets.filter(({ packet }) => unreceived[packetId(packet)].has(packet.sequence.toNumber()));\n            // However, some of these may have already been submitted as timeouts on the source chain. Check and filter\n            const valid = yield Promise.all(unreceivedPackets.map((packet) => __awaiter(this, void 0, void 0, function* () {\n                const { sourcePort, sourceChannel, sequence } = packet.packet;\n                try {\n                    // this throws an error if no commitment there\n                    yield src.client.query.ibc.channel.packetCommitment(sourcePort, sourceChannel, sequence);\n                    return packet;\n                }\n                catch (_a) {\n                    return undefined;\n                }\n            })));\n            return valid.filter((x) => x !== undefined);\n        });\n    }\n    getPendingAcks(source, opts = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.logger.verbose(`Get pending acks on ${this.chain(source)}`);\n            const { src, dest } = this.getEnds(source);\n            const allAcks = yield src.queryWrittenAcks(opts);\n            const toFilter = allAcks.map(({ originalPacket }) => originalPacket);\n            const query = (port, channel, sequences) => __awaiter(this, void 0, void 0, function* () {\n                const res = yield dest.client.query.ibc.channel.unreceivedAcks(port, channel, sequences);\n                return res.sequences.map((seq) => seq.toNumber());\n            });\n            const unreceived = yield this.filterUnreceived(toFilter, query, ackId);\n            return allAcks.filter(({ originalPacket: packet }) => unreceived[ackId(packet)].has(packet.sequence.toNumber()));\n        });\n    }\n    filterUnreceived(packets, unreceivedQuery, idFunc) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (packets.length === 0) {\n                return {};\n            }\n            const packetsPerDestination = packets.reduce((sorted, packet) => {\n                var _a;\n                const key = idFunc(packet);\n                return Object.assign(Object.assign({}, sorted), { [key]: [...((_a = sorted[key]) !== null && _a !== void 0 ? _a : []), packet.sequence.toNumber()] });\n            }, {});\n            const unreceivedResponses = yield Promise.all(Object.entries(packetsPerDestination).map(([destination, sequences]) => __awaiter(this, void 0, void 0, function* () {\n                const [port, channel] = destination.split(idDelim);\n                const notfound = yield unreceivedQuery(port, channel, sequences);\n                return { key: destination, sequences: notfound };\n            })));\n            const unreceived = unreceivedResponses.reduce((nested, { key, sequences }) => {\n                return Object.assign(Object.assign({}, nested), { [key]: new Set(sequences) });\n            }, {});\n            return unreceived;\n        });\n    }\n    // Returns the last height that this side knows of the other blockchain\n    lastKnownHeader(side) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function* () {\n            this.logger.verbose(`Get last known header on ${this.chain(side)}`);\n            const { src } = this.getEnds(side);\n            const client = yield src.client.query.ibc.client.stateTm(src.clientID);\n            return (_c = (_b = (_a = client.latestHeight) === null || _a === void 0 ? void 0 : _a.revisionHeight) === null || _b === void 0 ? void 0 : _b.toNumber()) !== null && _c !== void 0 ? _c : 0;\n        });\n    }\n    // this will update the client if needed and relay all provided packets from src -> dest\n    // if packets are all older than the last consensusHeight, then we don't update the client.\n    //\n    // Returns all the acks that are associated with the just submitted packets\n    relayPackets(source, packets) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.logger.info(`Relay ${packets.length} packets from ${this.chain(source)} => ${this.otherChain(source)}`);\n            if (packets.length === 0) {\n                return [];\n            }\n            const { src, dest } = this.getEnds(source);\n            // check if we need to update client at all\n            const neededHeight = Math.max(...packets.map((x) => x.height)) + 1;\n            const headerHeight = yield this.updateClientToHeight(source, neededHeight);\n            const submit = packets.map(({ packet }) => packet);\n            const proofs = yield Promise.all(submit.map((packet) => src.client.getPacketProof(packet, headerHeight)));\n            const { logs, height } = yield dest.client.receivePackets(submit, proofs, headerHeight);\n            const acks = utils_2.parseAcksFromLogs(logs);\n            return acks.map((ack) => (Object.assign({ height }, ack)));\n        });\n    }\n    // this will update the client if needed and relay all provided acks from src -> dest\n    // (yes, dest is where the packet was sent, but the ack was written on src).\n    // if acks are all older than the last consensusHeight, then we don't update the client.\n    //\n    // Returns the block height the acks were included in, or null if no acks sent\n    relayAcks(source, acks) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.logger.info(`Relay ${acks.length} acks from ${this.chain(source)} => ${this.otherChain(source)}`);\n            if (acks.length === 0) {\n                return null;\n            }\n            const { src, dest } = this.getEnds(source);\n            // check if we need to update client at all\n            const neededHeight = Math.max(...acks.map((x) => x.height)) + 1;\n            const headerHeight = yield this.updateClientToHeight(source, neededHeight);\n            const proofs = yield Promise.all(acks.map((ack) => src.client.getAckProof(ack, headerHeight)));\n            const { height } = yield dest.client.acknowledgePackets(acks, proofs, headerHeight);\n            return height;\n        });\n    }\n    // Source: the side that originally sent the packet\n    // We need to relay a proof from dest -> source\n    timeoutPackets(source, packets) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.logger.info(`Timeout ${packets.length} packets sent from ${this.chain(source)}`);\n            if (packets.length === 0) {\n                return null;\n            }\n            const { src, dest } = this.getEnds(source);\n            const destSide = otherSide(source);\n            // We need a header that is after the timeout, not after the packet was committed\n            // This can get complex with timeout timestamps. Let's just update to latest\n            yield dest.client.waitOneBlock();\n            const headerHeight = yield this.updateClient(destSide);\n            const rawPackets = packets.map(({ packet }) => packet);\n            const proofAndSeqs = yield Promise.all(rawPackets.map((packet) => __awaiter(this, void 0, void 0, function* () {\n                const fakeAck = {\n                    originalPacket: packet,\n                    acknowledgement: new Uint8Array(),\n                };\n                const { nextSequenceReceive: sequence } = yield dest.client.query.ibc.channel.nextSequenceReceive(packet.destinationPort, packet.destinationChannel);\n                const proof = yield dest.client.getTimeoutProof(fakeAck, headerHeight);\n                return { proof, sequence };\n            })));\n            const proofs = proofAndSeqs.map(({ proof }) => proof);\n            const seqs = proofAndSeqs.map(({ sequence }) => sequence);\n            const { height } = yield src.client.timeoutPackets(rawPackets, proofs, seqs, headerHeight);\n            return height;\n        });\n    }\n    getEnds(src) {\n        if (src === 'A') {\n            return {\n                src: this.endA,\n                dest: this.endB,\n            };\n        }\n        else {\n            return {\n                src: this.endB,\n                dest: this.endA,\n            };\n        }\n    }\n}\nexports.Link = Link;\nconst idDelim = ':';\nconst packetId = (packet) => `${packet.destinationPort}${idDelim}${packet.destinationChannel}`;\nconst ackId = (packet) => `${packet.sourcePort}${idDelim}${packet.sourceChannel}`;\nfunction createClients(nodeA, nodeB, \n// number of seconds the client (on B pointing to A) is valid without update\ntrustPeriodA, \n// number of seconds the client (on A pointing to B) is valid without update\ntrustPeriodB) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // client on B pointing to A\n        const args = yield ibcclient_1.buildCreateClientArgs(nodeA, trustPeriodA);\n        const { clientId: clientIdB } = yield nodeB.createTendermintClient(args.clientState, args.consensusState);\n        // client on A pointing to B\n        const args2 = yield ibcclient_1.buildCreateClientArgs(nodeB, trustPeriodB);\n        const { clientId: clientIdA } = yield nodeA.createTendermintClient(args2.clientState, args2.consensusState);\n        return [clientIdA, clientIdB];\n    });\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGluay5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvbGluay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSx5Q0FBbUQ7QUFFbkQsa0VBQTRFO0FBRzVFLHlDQUtvQjtBQUNwQiwyQ0FNcUI7QUFDckIscUNBQThDO0FBQzlDLG1DQU1pQjtBQVFqQixTQUFnQixTQUFTLENBQUMsSUFBVTtJQUNsQyxJQUFJLElBQUksS0FBSyxHQUFHLEVBQUU7UUFDaEIsT0FBTyxHQUFHLENBQUM7S0FDWjtTQUFNO1FBQ0wsT0FBTyxHQUFHLENBQUM7S0FDWjtBQUNILENBQUM7QUFORCw4QkFNQztBQVdEOzs7Ozs7R0FNRztBQUNILE1BQWEsSUFBSTtJQWdPZiw4REFBOEQ7SUFDOUQsMENBQTBDO0lBQzFDLFlBQW1CLElBQWMsRUFBRSxJQUFjLEVBQUUsTUFBZTtRQUNoRSxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNqQixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNqQixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sYUFBTixNQUFNLGNBQU4sTUFBTSxHQUFJLElBQUksbUJBQVUsRUFBRSxDQUFDO1FBQ3pDLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUM7UUFDbEMsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQztJQUNwQyxDQUFDO0lBaE9PLEtBQUssQ0FBQyxJQUFVO1FBQ3RCLElBQUksSUFBSSxLQUFLLEdBQUcsRUFBRTtZQUNoQixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7U0FDcEI7YUFBTTtZQUNMLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztTQUNwQjtJQUNILENBQUM7SUFFTyxVQUFVLENBQUMsSUFBVTtRQUMzQixJQUFJLElBQUksS0FBSyxHQUFHLEVBQUU7WUFDaEIsT0FBTyxJQUFJ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"]},"metadata":{},"sourceType":"script"}